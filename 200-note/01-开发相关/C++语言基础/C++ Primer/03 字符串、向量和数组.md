---
title: 02 变量和基本类型
category: 学习
type: 归纳整理
tags:
    - C++学习
    - C++_Primer
    - note
---

## 命名空间的 using 声明

如果想要调用特定命名空间的对象，可以通过下语句声明该名称

```cpp
using namespace::name;		// 声明语句
```

**eg:**

```cpp
using std::cin;
```

> [!info] 每个名字都需要独立的 using 声明

> [!danger] 头文件不应包含 using 声明
> 位于头文件的代码一般不应该使用 using 声明。因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个 using 声明，那么每个使用了该头文件的文件就都会有这个声明。对于某些程序来说，由于不经意间包含了一些名字，反而可能产生始料未及的名字冲突。

## 标准库类型 string

`string` 表示可变长的字符序列

**C++ 标准一方面对库类型所提供的操作做了详细规定，另一方面也对库的实现者做出一些性能上的需求。因此，标准库类型对于一般应用场合来说有足够的效率。**

### 定义和初始化 `string` 对象

**直接初始化:**

```cpp
string s1("hiya");
string s2(10,'c');
```

**拷贝初始化:**

```cpp
string s1 = "hiya";
string s2 = string(10,'c');
string s3 = s1;
```

### string 对象上的操作

类除了要规定初始化其对象地方式以外，还要定义对象上所能执行的操作。其中，类既能定义通过函数名调用的操作，也能定义 `<<`、`+` 等各种运算符在该类对象上的新含义

| string 操作          | 解释                                                           |
| -------------------- | -------------------------------------------------------------- |
| `os<<s`              | 将 `s` 写到输出流 `os` 中，返回 `os`                           |
| `is>>s`              | 将 `is` 中读取字符串赋给 `s`，字符串以空白分隔，返回 `is`      |
| `getline(is, s)`     | 将 `is` 中读取一行赋给 `s`，返回 `is`                          |
| `s.empty()`          | `s` 为空返回 `true`，否则返回 `false`                          |
| `s.size()`           | 返回 `s` 中字符的个数                                          |
| `s[n]`               | 返回 `s` 中第 `n` 个字符的引用，位置从 0 开始                  |
| `s1+s2`              | 返回 `s1` 和 `s2` 连接后的结果                                 |
| `s1=s2`              | 用 `s2` 的副本代替 `s1` 原来的字符                             |
| `s1==s2`             | 如果 `s1` 和 `s2` 中所含的字符完全一致，则它们相等：大小写敏感 |
| `s1!=s2`             | 同上，不过时否定判断                                           |
| `<`、`<=`、`>`、`>=` | 利用字符在字典中的顺序进行比较，大小写敏感                     |

#### 使用 `cin`，`cout` 读写 string 对象

在执行读取操作时，string 对象会**自动忽略开头的空白**(空格、换行符、制表符等)并从第一个真正的字符开始读起，**直到遇到下一处空白**。也就是说上示例如果输入 `Hello World!`，实际上读入的是 `Hello`。

和内置类型的输入输出操作一样，string 对象的此类操作也是返回运算符左侧的运算对象作为其结果。所以多个输入或者多个输出可以写在一起

**eg:**

```cpp
string s;
cin >> s;           // Hello World！
cout << s << endl;  // Hello

string s1, s2;
cin >> s1 >> s2;			// 输入"hello world!"，s1接收hello s2接收world!
cout << s1 << s2 << endl;
```

#### 读取未知数量的 string 对象

```cpp
int main(){
	string word;
	while(cin >> word)
		cout << word << endl;
	return 0;
}
```

如何结束 `cin` 循环 ：[[01 C++ 简介#读取不定量的输入数据]]

#### 使用 getline 读取一整行

```cpp
string line;
getline(cin, line);
```

如示例代码，可以通过这种方式将 `cin` 的一整行的内容如读取到 `line` 中。`getline` 只要遇到换行符就结束读取操作并返回。与 `>>` 一样，`getline` 也会返回它的流参数。所以 `getline` 也可以作为条件表达式使用。

**触发 `getline` 函数返回的那个换行符实际上被丢弃了，得到的 `string` 对象中并不包含换行符。**

#### string 的 empty 和 size 操作

`empty` 是 `string` 的成员函数，用于判断该 `string` 对象是否为空。

```cpp
while (getline(cin. line))
	if (!line.empty()) cout << line << endl;
```

`size` 函数返回 `string` 对象的长度(也就是 `string` 对象中字符的个数)，可以使用 `size` 函数只输出长度超过 80 个字符的行：

```cpp
string line;
// 每次读入一行，只有字符超过80才输出
while (getline(cin, line))
    if (line.size() > 80)
        cout << line << endl;
```

#### string::size_type 类型

对于 `size` 函数来说，其实返回的不是 `int` 或者 `unsigned`，而是 `string::size_type` 类型的值。（体现标准库类型与机器无关的特性）`size_type` 是一个无符号类型的值，且能存放任何 `string` 对象的大小。

C++11 新增允许编译器通过 `auto` 或者 `decltype` 来推断变量的类型

```cpp
auto len = line.size();		// len的类型是string::size_type
```

#### 比较 string 对象

1. 如果两个 `string` 对象的长度不同，短 `string` 对象的每个字符都跟长 `string` 对象对应的字符相同，那么短 `string` 小于长 `string`
2. 如果两个 `string` 对象在某些对应的位置上不一致，则 `string` 对象比较的结果是 `string` 对象中第一对相异字符比较的结果

```cpp
string str = "Hello";
string pharse = "Hello World";
string slang = "Hiya";
```

根据规则一可得：`str < pharse`

根据规则二可得：`slang>pharse>str`

#### 为 string 对象赋值

```cpp
string st1(10,'c'),st2;		// st1 = cccccccccc st2 = ""
st1 = st2;					// st1 = "" st2 = ""
```

#### 两个 string 对象相加

```cpp
string s1 = "hello, ", s2 = "world\n";
string s3 = s1 + s2;			// s3 = "hello, world\n"
s1 += s2;						// s1 = "hello, world\n"
```

> [!danger] 当把 `string` 对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个 `+` 两侧的运算对象至少有一个是 `string`。因为某些历史原因，也为了与 C 兼容，所以 C++ 语言中的字符串字面值不是标准库类型 `string` 的对象。

### 处理 string 对象中的字符

`cctype` 头文件（字符处理库）中定义了有关字符判断与处理的库函数

| cctype 头文件中的函数 | 解释                                                                      |
| --------------------- | ------------------------------------------------------------------------- |
| `isalnum(c)`          | 当 `c` 是字母或数字时为真                                                 |
| `isalpha(c)`          | 当 `c` 是字母时为真                                                       |
| `iscntrl(c)`          | 当 `c` 是控制字符时为真                                                   |
| `isdigit(c)`          | 当 `c` 是数字时为真                                                       |
| `isgraph(c)`          | 当 `c` 不是空格但可以打印时为真                                           |
| `islower(c)`          | 当 `c` 是小写字母时为真                                                   |
| `isprint(c)`          | 当 `c` 是可打印字符时为真(即 `c` 是空格或 `c` 具有可视形式)               |
| `ispunct(c)`          | 当 `c` 是标点符号时为真(即 `c` 不是控制字符、数字、字母等)                |
| `isspace(c)`          | 当 `c` 是空白时为真(空格、横向制表符、纵向制表符、回车符、换行符、进纸符) |
| `isupeer(c)`          | 当 `c` 是大写字母时为真                                                   |
| `isxdigit(c)`         | 当 `c` 是十六进制数字时为真                                               |
| `tolower(c)`          | 如果 `c` 是大写字母，输出对应的小写字母，否则原样输出 `c`                 |
| `toupper(c)`          | 如果 `c` 是小写字母，输出对应的大写字母，否则原样输出 `c`                 |

#### 建议使用 C++ 版本的 C 标准库头文件。

C++ 标准库中除了定义 C++ 语言特有的功能外，也兼容了 C 语言的标准库。C 语言的头文件形如 `name.h`，C++ 则将这些文件命名为 `cname`。也就是去掉了 `.h` 后缀，而在文件名 `name` 之前添加了 `c`，这里的 `c` 表示这是一个属于 C 语言标准库的头文件。

#### 处理每个字符

C++11 新增语句**范围 `for`**(range for)语句。这种语句遍历给定序列中的每个元素并对序列中的每个值执行某种操作：

```cpp
for (declaration : expression)
	statement
```

其中 `expression` 部分是一个对象，用于表示一个序列。`decllaration` 部分负责定义一个变量，该变量会被用在访问序列中的基础元素。每次迭代，`declaration` 部分的变量会被初始化为 `expression` 部分的下一个元素值。

```cpp
string str("some string");
for (auto c : str)
	cout << c << enldl;
```

#### 使用范围 for 语句改变字符串中的字符

如果想修改 `string` 对象中字符的值，必须把循环变量定义成引用类型。所谓引用只是给对象的一个别名，所以如果使用引用作为循环控制变量，这个变量实际上被依次绑定到了序列的每个元素。使用该引用，就能改变它绑定的字符。

```cpp
string s("Hello World!!!");
for (auto &c : s) c = toupper(c);
cout << s << endl;			// s = HELLO WORLD!!!
return 0;
```

#### 只处理一部分字符

想访问 `string` 对象中的单个字符有两种方式：

1. 使用下标
2. 使用迭代器

> [!info] 下标运算符 `[] ` 接收的输入参数是 `string::size_type` 类型的值，这个参数表示要访问的字符的位置。返回值是该位置上字符的引用。下标的值又称**索引**，任何表达式只要它的值是一个整型值就能作为索引。但是如果某个索引是带符号类型的值就会自动转换成由 `string::size_type` 表达的无符号类型。只要字符串不是常量就能通过下标运算符给其重新赋值。

`eg:`

```cpp
int main(){
    // 依次处理s中的字符直到处理完全部字符或者遇到一个空白
    for (
        decltype(s.size()) index = 0;
        index != s.size() && !sspace(s[index]);	// 当前下标不跟字符全长相同也不是空
        ++index
        )
        s[index] = toupper(s[index]);           // 将当前字符改成大写
}
```

#### 使用下标执行随机访问

也可以通过计算获得某个下标值，然后直接获取对应位置的字符

示例把 0 到 15 之间的十进制数转换成对应的十六进制形式，只需初始化一个字符串令其存放 16 个十六进制“数字”

```cpp
int main(){
    const string hexdigits = "0123456789ABCDEF";  // 可能的十六进制数字
    cout << "输入0到15间的数字" << endl;
    string result;                                // 保存16进制的字符串
    string::size_type n;                          // 保存从输入流读取的数
    cin >> n;
    if (n < hexdigits.size())
        result += hexdigits[n];
    cout << "对应的16进制数为:" << result << endl;
    system("pause");
    return 0;
}
```

## 标准类型 vector

标准库类型 **vector**(向量)表示对象的集合，其中所有对象的类型都想相同。每一个对象都有一个对应的索引，索引用于访问对象。因为 vector"容纳着"其他对象，所以它也常被称为**容器**(container)。

要想使用 vector，必须包含 `vector` 头文件。

```cpp
#include <vector>
using std::vector;
```

C++ 语言既有**类模板**(class template)，也有函数模板，其中 vector 是一个类模板。

模板本身不是类或者函数，可以将模板看成是编译器生成类或者函数编写的一份说明。编译器根据模板创建类或者函数的过程称之为**实例化**(instantiation)，使用模板的时候，需要指出编译器应该把类或者函数实例化成为哪种类型。

提供信息的方式：

```cpp
vector<int> ivec;					 // ivec 保存int类型的对象
vector<Sales_item> Sales_vec;		 // 保存Sales_item类型的对象
vector<vector<string>> file;		 // 该向量的元素是vector对象 类似于[[file]] file为string类型
```

> [!info] 注
>
> 1. `vector` 是模板而不是类型，由 `vector` 生成的类型必须含有 `vector` 中元素的类型，如 `vector<int>`；
> 2. `vector` 能容纳绝大多数的对象作为其元素，但是因为引用不是对象，所以不存在包含引用的 `vector`；
> 3. 大多数内置类型和类类型都可以构成 `vector` 对象，甚至组成 `vector` 的元素也可以是 `vector`。

### 定义和初始化 vector 对象

和任何一种类类型相同，vector 模板控制着定义和初始化 vector 的方法。

| 方法                          | 含义                                                              |
| ----------------------------- | ----------------------------------------------------------------- |
| `vector<T> v1`                | v1 是个空 vector，潜在元素是 T 类型，执行默认初始化，不含任何元素 |
| `vector<T> v2(v1)`            | v2 中包含有 v1 所有元素的副本                                     |
| `vector<T> v2 = v1`           | 与 v2(v1)相同，v2 包含 v1 所有元素的副本                          |
| `vector<T> v3(n, val)`        | v3 包含了 n 个重复的元素，每个元素的值都是 val                    |
| `vector<T> v4(n)`             | v4 包含了 n 个重复地执行了值初始化对象                            |
| `vector<T> v5 {a, b, c...}`   | v5 包含了初始值个数的元素，每个元素被赋予相应的初始值             |
| `vector<T> v5 = {a, b, c...}` | 与 v5 {a, b, c...}相同                                            |

#### 列表初始化 vector 对象

C++11 新标准提供的方法。

```cpp
vector<string> articles = {"a", "an", "the"};
```

在大多时候这些初始化方式可以相互等价使用，但并非一直可以。

1. 使用拷贝初始化时候(=)，只能提供一个初始值
2. 若提供的是一个类内初始值，则只能使用拷贝初始化或者花括号的形式初始化。
3. 如果提供的是初始化元素值的列表，则只能把初始值都放在花括号里进行列表初始化。而不能放在圆括号里。

#### 值初始化

可以只提供 vector 对象容纳的元素数量而略去初始值。此时库会创建一个**值初始化的**(value-initialized)元素初值，并把它赋给容器中的所有元素。该初值由 vector 对象中的元素类型决定。

这种初始化方式有两个特殊限制：

1. 有些类要求必须明确地提供初始值，如果 vector 对象中元素的类型不支持默认初始化，我们就必须提供初始的元素值。
2. 如果只提供了元素的数量而没有设定初始值，只能使用直接初始化

#### 列表初始化

如果是花括号，可以表述成我们想**列表初始化**(list initialize)该 vector 对象。也就是说，初始化过程会尽可能地把花括号内地值当成是元素初始值的列表来处理，只有在无法执行列表初始化时才会考虑其他初始化方式。如果初始化时候使用了花括号地形式但是提供的值又不可以用来列表初始化，就要考虑用这样的值来构造 vector 对象了。

**eg:**

```cpp
vector<string> v5{"hi"};		// 正确 列表初始化
vector<string> v6("hi");		// 错误 构造
vector<string> v7{10};			// 正确 v7有10个默认初始化的元素 不是列表初始化
vector<string> v8{10, "hi"};	// 正确 v8 有10个为"hi"的元素 不是列表初始化
```

> [!danger] 确认无法执行列表初始化后，编译器会尝试使用默认值初始化 vector 对象。

### 向 vector 对象添加元素

#### vector 操作

| 操作                     | 含义                                                                      |
| ------------------------ | ------------------------------------------------------------------------- |
| `v.empty()`              | 判断 `v` 是否为空                                                         |
| `v.size()`               | 返回 `v` 元素个数                                                         |
|                          | 返回类型是 vector 定义的 `size_type` 类型 `vector<该容器类型>::size_type` |
| `v.push_back(t)`         | 给 `v` 尾端添加 `t` 元素                                                  |
| `v[n]`                   | 返回 `v` 中第 `n` 个位置上元素的引用                                      |
| `v1 = v2`                | `v2` 的所有元素拷贝给 `v1`                                                |
| `v1 = {a,v,c...}`        | 用花括号中的元素替换 `v1` 中的元素                                        |
| `v1 == v2` 、 `v1 != v2` | 判断两个容器元素是否相等                                                  |
| `<,<=,>,>=`              | 字典顺序进行比较                                                          |

```cpp
vector<int> v{1,2,3,4,5,6,7,8,9}
for(auto &i : v)		// 对于v中的每个元素(i是一个引用)
	i *= i;			    // i = i * i(平方)
for (auto i : v)		// 使用i遍历v中的每个值
	cout << i << " ";	// 输出i的值
cout << endl;			// 结束，刷新缓冲区
```

各个相等性运算符和关系运算符也与 string 的相应运算符功能相同。

#### 比较两个 vector

如果两个 vector 对象的容量不同：

- 相同位置上的元素值相同，则元素少的 vector 对象小于长的；
- 若元素的值有区别，则由第一对不同的元素值的大小关系决定。

> [!info] 只有元素的值可以比较时候，vector 对象才能被比较。例如 int 和 string 可以，但是有时候如 Sales_item 就不能。像 `vector<Sales_item>` 这样就不能比较，而只能存值

#### 计算 vector 里对象的索引

使用下标运算符可以获取对应位置的元素。下标类型是相应的 `size_type` 类型。只要 vector 对象不是一个常量，就能向下标运算符返回的元素赋值。

## 迭代器介绍

string 和 vector 都支持迭代器。可以使用**迭代器**(iterator)来访问 string 或 vector 对象

类似于指针类型，迭代器也提供了对对象的间接访问。就迭代器而言，其对象是容器中的元素或者 string 对象中的字符。使用迭代器可以访问某个元素，迭代器也可以从一个元素移动到另一个元素。

迭代器有有效与无效区别：

- 有效的迭代器指向某个元素，或者指向容器中尾的下一个位置
- 其它的情况都属于无效的迭代器。

### 使用迭代器

有迭代器的类型同时拥有返回迭代器的成员。

例如，这些类型都含有名为 **begin** 和 **end** 的成员，其中 begin 成员负责返回指向第一个元素(或者一个字符)的迭代器。

```cpp
// 由编译器决定b和e的类型
// b表示v的第一个元素 e表示v尾元素的下一个位置
auto b = v.begin(), e = v.end(); // b和e的类型相同
```

`end` 成员返回指向容器(或者 string 对象)尾元素的**下一个位置**(one past the end)的迭代器，也就是说，该迭代器指的是容器一个本不存在的**尾后**(off the end)元素。这样的迭代器表示我们已经处理完成容器中的所有元素。

`end` 成员返回的迭代器常称**尾后迭代器**(off-the-end iterator)或者**尾迭代器**(end iterator)。

若容器为空，那么 `begin` 和 `end` 返回同一个迭代器，都是尾迭代器。

#### 迭代器运算符

| 运算符使用       | 含义                                                           |
| ---------------- | -------------------------------------------------------------- |
| `*iter`          | 返回迭代器 iter 所指元素的引用                                 |
| `iter->mem`      | 解引用 iter 并获取该元素的名为 mem 的成员，等价于`(*iter).mem` |
| `++iter`         | 令 iter 指示容器的下一个元素                                   |
| `--iter`         | 令 iter 指示容器的上一个元素                                   |
| `iter1 == iter2` | 判断两个迭代器是否相等，若两个迭代器指示的是同                 |
|                  | 一个元素或者是同一个容器的尾后迭代器就相等，否则就不相等       |
| `iter1 != iter2` | 对上一个含义的结果取反                                         |

#### 将迭代器从一个元素移动到另外一个元素

迭代器使用递增(++)运算符来从一个元素移动到下一个元素。逻辑上说，迭代器的递增和整数的递增，整数的递增是在整数值上 `加 1`，迭代器的递增是把迭代器 `向前移动一格位置`。因为 `end` 返回的迭代器并不实际指向某个元素，所以不能对其进行递增或者解引用的操作。

**eg:使用迭代器将一个单词转换为大写**

```cpp
// 以此处理s的字符直至我们处理完全部字符或者遇到空白
for (auto it = s.begin(); it != s.end() && !isspace(*it); ++it)
	*it = toupper(*it);
```

> [!danger] 大多从 C 或者 JAVA 转来 C++ 的人可能会使用 `<` 而非 `!=`。所有标准库容器的迭代器都定义了 `==` 和 `!=`，但它们的大多数都没有定义 `<` 运算符。

#### 迭代器类型

那些拥有迭代器的标准库类型使用 `iterator` 和 `const_iteraor` 来表示迭代器的类型

```cpp
vector<int>::iterator it;			// it能读写vector<int>的元素
string::iterator it2;				// i2能读写string对象中的字符

vector<int>::const_iterator it3;	// it3只能读元素 不能写元素
string::const_iterator it4;			// it4只能读字符 不能写字符
```

> [!info] `const_iterator` 和常量指针类似。若 `vector` 对象或 `string` 对象是一个常量，只能使用 `const_iterator`；若 `vector` 对象或 `string` 对象不是常量，那么两种都能用。

#### begin 和 end 运算符

如果对象是常量，那么 `begin` 和 `end` 返回 `const_iterator`，如果对象非常量，就返回 `iterator`

若只使用读操作那最好就用常量类型(const_iterator)。为了便于得到 `const_iterator`，C++11 新标准引入 `cbegin`、`cend`

```cpp
auto it3 = v.cbegin();		// it3的类型是const_iterator
```

`cbegin` 与 `cend` 作用类似 `begin` 和 `end`，不过它们返回的固定是 `const_iterator`，不可修改。

#### 结合解引用和成员访问操作

```cpp
vector<string> v{"a", "b"};
auto it = v.cbegin();

(*it).empty();           // 判断*it是否为空 也就是通过迭代器判断v是否为空容器
```

为了简化如上步骤，C++ 语言定义了**箭头运算符** `->`。

箭头运算符把解引用和成员访问两个操作结合在一起，也就是说，`it->mem` 与 `(*it).mem` 相同。

```cpp
// 依次输出text的每一行直到遇到第一个空白行为止
for (auto it = text.cbegin(); it != text.cend() && it->empty(); ++it)
	cout << *it << endl;
```

`it->empty()` 将 `it` 的值取出然后使用 `empty()` 函数判断是否为空

使用箭头运算符将一个单词转为大写。

```cpp
string s = "hello world!";
for (auto it = text.begin(); it != text.cend() && it->empty(); ++it))
	*it = toupper->it;
cout << s << endl;
```

> [!danger] 某些对 vector 对象的操作会使迭代器失效

1. 一个限制是不能在范围 for 循环中向 vector 对象添加元素。
2. 另外一个限制是任何一种可能改变 vector 对象容量的操作，如 push_back 都会使得该 vector 对象的迭代器失效。

### 迭代器运算

| vector 和 string 迭代器支持的操作 | 介绍                                                                       |
| --------------------------------- | -------------------------------------------------------------------------- |
| `iter + n`                        | 迭代器向前移动 `n` 个位置                                                  |
| `iter - n`                        | 与 `+` 相反，不过如果还是超了那还是指是尾元素的下一个位置                  |
| `iter1 += n`                      | 将 `iter1` + `n` 的结果赋给 `iter1`                                        |
| `iter1 -= n`                      | 将 `iter1` - `n` 的结果赋给 `iter1`                                        |
| `iter1 - iter2`                   | 两个迭代器相减结果是它们之间的距离。                                       |
|                                   | 也就是将运算符右侧的迭代器向前移动差值个元素后就得到左边的迭代器。         |
|                                   | 参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一个位置。 |
| `>、>=、<、<=`                    | 若某迭代器指向的容器位置在另一个迭代器所指向位置前，则前者小于后者。       |
|                                   | 参与运算的两个迭代器必须指向同一个容器中的元素或者尾元素的下一位置。       |

这些运算符称为**迭代器运算**(iterator arithmetic)，可以使得迭代器每次移动跳过多个元素，也支持迭代器进行关系运算。

#### 迭代器的算术运算

```cpp
// 计算得到最接近vi中间元素的一个迭代器
auto mid = vi.begin() + vi.size() / 2;
```

若 `vi` 有 20 个元素，那么 `vi.size()/2` ​ 得到 10，此例中即是 `mid` 等于 `vi.begin()+10`。

已知下标从 0 开始，则迭代器所指的元素是 `vi[10]`，也就是首元素开始向前相隔 10 个位置的那个元素。

于 `string` 或 `vector` 的迭代器而言，除了判断是否相等，还能使用关系运算符对其进行比较。参与比较的两个迭代器必须合法且指向同一个容器元素(或尾元素的下一位置)。如 `it` 和 `mid` 是同一个容器对象，那么可以使用 `if(it < mid)` 来比较它们所指的位置先后。

所谓两个迭代器的距离指的是右侧迭代器向前移动多少位置就能追上左侧的迭代器，其类型是名为 `defference_type` 的带符号整数。`string` 和 `vector` 都定义了 `defference_type`。

## 数组

数组是种类似于标准库类型 vector 的数据结构，但是在性能和灵活性的权衡上又跟 vector 有些不一样。与 vector 相似的地方是，数组也是存放在类型相同的对象的容器。这些对象本身没有名字，需要通过其所在位置访问。与 vector 不同的地方是，数组的大小固定。对于某些特殊的应用来说程序的运行时性能较好，但也损失了一些灵活性。

如果不清楚元素的确切个数，应该使用 vector。

### 定义和初始化内置数组

`a[d]`，其中 a 是数组的名字，d 是数组的维度。维度说明了数组中元素的个数，因此必须大于 0。数组中元素的个数也属于数组类型的一部分，编译的时候维度应该是已知的。也就是说，维度必须是一个常量表达式。

```cpp
 unsigned cnt = 42;				// 非常量表达式
 constexpr unsigned sz = 42;	// 常量表达式
 int arr[10];					// 含有10个int类型的数的数组
 int *parr[sz];					// 含有42个int类型的指针的数组
 string bad[cnt];				// 错误 cnt非常量表达式
 string strs[get_size()];		// 如果get_size()是constexpr时正确 否则错误
```

与内置类型的变量相同，若函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。定义数组时必须明确定义数组的类型，不能使用 auto 关键字由初始值的列表推断类型。数组的元素应该是对象，不存在引用的数组。

#### 显示初始化数组元素

可以对数组的元素进行列表初始化，此时允许忽略数组的维度。若声明时没有指明维度，编译器会根据初始值的数量计算并推测出来；相反，如果指明了维度，那么初始值的总数量就不该超出指定的大小。

```cpp
const unsigned sz = 3;
int ia1[sz] = {0, 1, 2};		// 含有3个元素的数组
int a2[] = {0, 1, 2};			// 含有3个元素的数组
int a3[5] = {0, 1, 3};			// 含有5个元素的数组 前3个是0,1,2 后两个由int初始化为0,0
string a4[3] = {"hi", "bye"};	// 含有3个元素的数组 前两个是"hi","bye" 最后一个是""
int a5[2] = {0,1,2};			// 错误 初始值超出指定维度
```

#### 字符数组的特殊性

字符数组有一种额外的初始化形式，我们可以用字符串字面值对此类数组初始化。包括字符串字面值的末尾那个空字符 `\0` 也会被添加进去。

```cpp
char a1[] = {'C', '+', '+'};		// 列表初始化 无空字符
char a2[] = {'C', '+', '+', '\0'};	// 列表初始化 含有显示的空字符
char a3[] = "C++";					// 列表初始化 含有隐式的空字符\0
const char a4[6] = "Daniel";		// 错误 虽然字符串字面值看着只有6个字符 但是实际上还有个\0没有显示出来
```

#### 不允许拷贝和赋值

不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值。

```cpp
int a[] = {0, 1, 2};
int a2[] = a;			// 错误 不允许使用一个数组初始化另一个数组
a2 = a;					// 错误 不能把一个数组直接赋值给另一个数组
```

一些编译器允许数组赋值，即**编译器扩展**(compiler extension)。但一般来说，不应该使用非标准特性。

#### 理解复杂的数组声明

默认情况下，类型修饰符从右向左依次绑定。

```cpp
int *ptrs[10];		// 定义一个大小为10的数组 名字是ptrs 数组存放的是指向int类型的指针
					// 十个指向int的指针的数组
```

但是有时候我们也需要从内往外理解

```cpp
int (*Parray)[10] = &arr;		//  指向一个含有10个整数的数组的指针
```

`(*Parray)` 表示 `Parray` 是个指针，接下来看右边可以得知 `Parray` 是个指向大小为 `10` 的数组的指针，最后再看左边，得知数组中的元素是 `int`。即 `Parray` 是个指针，指向一个 `int` 数组，数组中含有 `10` 个元素。

### 访问数组元素

与标准库类型 vector 和 string 一样，数组的元素也能使用范围 for 语句或下标运算符来访问。数组的索引从 0 开始。

在使用数组下标时，通常将其定义为 **size_t** 类型。size_t 是一种机器相关的无符号类型，它被设计得足够大以便能表示内存中任意对象的大小。在 `cstddef` 头文件中定义了 size_t 类型，这个文件是 C 标准库 `stddef.h` 头文件的 C++ 版本。数组所用下标是 C++ 直接定义的，而 vector 的下标是由库模板 vector 定义的。与 vector 一样，如果不想超出数组的范围，最好是用范围 for 循环。

#### 检查下标的值

与 vector 和 string 一样，数组的下表是否在合理范围之内由程序员负责检查，所谓合理就是说下标应该大于等于 0 且小于数组的大小。要想防止数组下标越界，除了注意细节以及对代码彻底的测试之外，没有其它好办法。于程序而言，即使能顺利编译过去，也不能肯定它不包含这些问题。

### 指针和数组

在 C++ 中，使用数组时候编译器一般会将其转换为指针。通常使用取地址符来获取指向某个对象的指针，取地址符可以用于任何对象。数组的元素也是对象，对数组使用下标运算符得到该数组指定位置的元素。对数组的元素也可以使用取地址符，然后就能得到指向该元素的指针。

```cpp
string nums[] = {"one", "two", "three"};
string *p = &nums[0];		// 取的"one"的指针
```

在大多表达式中，使用数组类型的对象其实是使用一个指向该数组首元素的指针。在一些情况下对数组的操作实际上是指针的操作。当使用数组作为一个 auto 变量的初始值时，推断得出的类型是指针而不是数组。

#### 指针也是迭代器

vector 和 string 的迭代器数组都支持。

```cpp
int arr[] = {0,1,2,3,4,5,6,7,8,9};
int *p = arr;		// p指向&arr[0]
++p;				// arr[0+1] *p = arr[1]
```

获取数组的尾元素后那个不存在的元素的地址

```cpp
int *e = &arr[10];	// 指向arr尾元素的下一位置的指针
```

不能对尾后指针执行解引用或者递增等操作。

利用尾后指针打印 arr 的全部元素

```cpp
int *e = &arr[10];
for (int *b = arr;b!=e;++b)
	cout << *b << endl;
```

#### 标准库函数 begin 和 end

尽管能计算得到尾后指针，但这种用法容易出错。为了使指针的使用更见点，C++11 新增名为 begin 和 end 函数。但数组不是类类型，因此这两个函数不是成员函数。正确的使用方式是把数组作为它们的参数

```cpp
int ia[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
int *beg = begin(ia);			// 指向ia首元素的指针
int *last = end(ia);			// 指向ia尾元素的下一个位置的指针
```

这两个函数定义在 iterator 头文件中

使用 begin 和 end 可以简单地写出一个循环并处理数组中的元素。

```cpp
// 假设arr是个整型数组 找出arr中的第一个负数
// pbeg指向arr地首元素 pend指向arr尾元素的下一位置
int *pbeg = begin(arr), *pend = end(arr);
// 寻找第一个负值元素 如果已经检查完全部元素则结束循环
while(pbeg != pend && *pbeg >= 0)
	++pbeg;
```

#### 指针运算

指向数组元素的指针加或者减会移动指向数组中元素的位置

```cpp
constexpr size_t sz = 5;
int arr[sz] = {1,2,3,4,5};
int *ip = arr;			// = *ip = &arr[0]
int *ip2 = ip+4;		// = *ip2 = &arr[0+4] = &arr[4]
```

指向同一数组的尾元素的下一位置

```cpp
int *p = arr + sz;		// arr转换成指向arr首元素的指针 sz即是5 所以p指针指向&arr[5]，但是arr只有[4] 所以是arr数组的尾元素的下一位置
int *p2= arr + 10;		// 下标越界
```

与迭代器相同，两个指针相减的结果是它们之间的距离。参与运算的两个指针必须指向同一个数组当中的元素

```cpp
auto n = end(arr) - begin(arr);		// n的值是5 end(5) - begin(0) = 5
```

两指针相减的结果的类型是一种名为 **ptrdiff_t** 的标准库类型，和 `size_t` 一样，`ptrdiff_t` 也是一种定义在 `cstddef` 头文件中的机器相关的类型。因此差值可能是负值，所以 `ptrdiff_t` 是一种带符号类型。

#### 解引用和指针运算的交互

指针加上一个整数的结果还是一个指针。假设结果指针指向了一个元素，则允许解引用该结果指针

```cpp
int ia[]= {0,2,4,6,8};		// ia[5]
int last = *(ia+4);			// last = *ia[4] --> last = 8
```

如果表达式含有解引用符和点运算符，最好在必要的地方加上圆括号。

```cpp
last = *ia + 4;		// 正确 last = *ia[0] + 4 --> last = 0+4=4
```

含义就和之前的不同了，此时先解引用再给结果加 4

#### 下标和指针

```cpp
int ia[] = {0,2,4,6,8};		// 含有5个整数的数组

int i = ia[2];				// i = 4
int *p = ia;				// *p --> ia[0] --> 0  *p-->ia
i = *(p + 2);				// ia[0+2] --> ia[2] --> 4 --> i = 4
```

只要指针指向的是数组中的元素(或者数组中尾元素的下一位置)，都可以执行下标运算

```cpp
int *p = &ia[2];		// p指向索引为2的元素 --> &(ia[2]) --> &4 --> *p --> &4
int j = p[1];			// p[1]等价于*(p+1)，就是ia[3] --> 6 --> p[1]== *p = &ia[2+1] --> &6 --> j
int k = p[-2];			// *p= &ia[2-2] --> *p = 0 --> k = 0
```

可以理解为数组在内存中是一个一个方块排列，然后我们指针去访问数组的值时，就相当于访问内存当中的值。下标即是数组在内存当中排列的顺序。

标准库类型 `string` 和 `vector` 也能执行下标运算，但是标准库类型限定使用的下标必须是无符号类型，而内置的下标运算没有做这个限制。内置的下标运算符可以处理负值，但是结果地址必须指向原来的指针所指同一数组中的元素。

> [!info] 内置的下标运算符使用的索引值不是无符号类型，这一点与 vector 和 string 不同。

### C 语言风格字符串

虽然 C++支持 C 风格字符串，但在 C++程序中最好还是不要使用它们。不仅使用不方便，且容易引发程序漏洞。

字符串字面值是一种通用结构的示例，这种结构是 C++由 C 继承而来的**C 风格字符串**(C-style character string)。C 风格字符串不是一种类型，而是为了表达和使用字符串而形成的一种约定俗成的写法。按此习惯书写的字符串存放在字符数组中并以**空字符结束**(null terminated)。以空字符结束的意思是在字符串最后一个字符后面跟着一个空字符 `\0`。一般利用指针来操作这些字符串。

#### C 标准 String 函数

| 函数             | 含义                                                                   |
| ---------------- | ---------------------------------------------------------------------- |
| `strlen(p)`      | 返回 p 的长度，空字符不计算在内                                        |
| `strcmp(p1, p2)` | 比较 p1 和 p2 的相等性。两值相等返回 0，左大右小为正值，左小右大为负值 |
| `strcat(p1, p2)` | 将 p2 附加到 p1 之后，返回 p1                                          |
| `strcpy(p1, p2)` | 将 p2 拷贝给 p1，返回 p1                                               |

这些函数定义在 cstring 头文件中，cstring 是 C 语言头文件 string.h 的 C++版本。这些函数不会验证字符参数。

传入此类函数的指针必须要指向以空字符作为结尾的数组

```cpp
char ca[] = {'C', '+', '+'};			// 不以空字符结束
cout << strlen(ca) << endl;				// 错误 ca没有以空字符结束
```

#### 比较字符串

比较两个 C 风格字符串的方法和之前学习过的比较标准库 string 对象的方法类似。

```cpp
string s1 = "A string example";
string s2 = "A different string";
if (s1 < s2)		// 返回 false s2小于s1

// C风格字符串
// 实际比较的是指针而不是字符串本身
const char ca1[] = "A string example";
const char ca2[] = "A different string";
if (ca1 < ca2)		// 未定义的 试图比较两个无关地址
// 实际比较的是两个const char*的值 指针指的不是同一个(数组)对象 所以得到未定义的结果
```

要想比较两个 C 风格字符串需要调用 strcmp 函数，此时比较的就不再是指针了。

```cpp
if (strcmp(ca1, ca2) < 0)	// 和两个string对象比较s1 < s2效果一样
```

#### 目标字符串的大小由调用者指定

```cpp
// 将largeStr 初始化成s1、一个空格和s2的连接
string largeStr = s1 + " " + s2;
```

同样的操作放到 `ca1` 和 `ca2` 上就会报错。表达式 `ca1+ca2` 试图将两个指针相加，这样的操作是非法的。

我们若想这样使用，则需要使用 `strcat` 函数和 `strcpy` 函数。若想要用这两个函数，还必须提供一个用于存放结果字符串的数组，该数组必须足够大以便容纳下结果字符串及末尾的空字符。

下述代码虽然可以解决，但是极其容易引发错误，如果我们计算错了 `largeStr` 的大小就会引发严重的错误

```cpp
strcoy(largeStr, ca1);		// 将cal拷贝给LargeStr
strcat(largeStr, " ");		// 在largeStr末尾加上一个空格
strcat(largeStr, ca2);		// 在largestr末尾加上ca2
```

一个潜在的问题是，我们在估算 `largeStr` 所需要的空间时候不容易算准，而且 `largeStr` 所存的内容一旦改变，就必须重新检查其空间是否足够。

> [!info] 为什么两个指针相加没什么意义？
>
> 1. 指针相减代表的是两个指针间的距离，相加是为了得到什么？
> 2. 相加后的距离可能超出了内存的最大值或者指向某个不知道是什么东西的地址，可能导致越界
> 3. 指针和常量表达式相加减可以用于快速寻址，但是两个指针相加却可能会导致我们指向这两个指针范围外的地址。

### 与旧代码的接口

很多 C++ 程序在标准库出现前就写好了，它们没用到 string 和 vector 类型。且有些 C++程序实际上是与 C 语言或者其他语言的接口程序，当然也无法使用 C++标准库。

#### 混用 string 对象和 C 风格字符串

```cpp
string s("Hello World!");
```

更常见的情况是，任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代

- 允许使用以空字符结束的字符数组来初始化 string 对象或者为 string 对象赋值
- 在 string 对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象(只能有一个)；在 string 对象的符号赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象。

如果程序的某处需要一个 C 风格字符串，无法直接用 string 对象来代替它。

不能用 string 对象直接初始化指向字符的指针。

为完成该功能，string 专门提供一个名为 c_str 的成员函数

```cpp
char *str = s;						// 错误 不能直接用string对象初始化char*
const char *str = s.c_str();		// 正确
```

c_str()返回的是一个 C 风格字符串。也就是说函数的返回结果是个指针，该指针指向一个以空字符结束的字符数组，而该数组所存的数据恰好与那个 string 对象的一样。结果指针的类型是 const char\*。

后续的操作改变了 s 的值就有可能让之前返回的数组(c_str())失去作用。也就是说像一个只能使用 c_str()的返回值，最好是把他拷贝一遍。

#### 使用数组初始化 vector 对象

只需指明拷贝区域的首元素地址和尾元素地址就行

```cpp
int int_arr[] = {0,1,2,3,4,5};
// ivec 有6个元素 分别是int_arr中对应元素的副本
vector<int> ivec(begin(int_arr), end(int_arr));
// ivec与int_arr的元素数量相同 次序和值也完全相同
```

用于初始化 vector 对象的值也可能只是数组的一部分

```cpp
// 拷贝三个元素 int_arr[1]到int_arr[3]
vector<int> subVec(int_arr + 1, int_arr + 4);
```

> [!danger] 事实上我们应该尽量使用标准库类型而不要使用数组
> 使用指针和数组容易出错。现代的 C++程序应该尽量用 vector 和迭代器，避免使用内置数组和指针；应该尽量用 string，避免使用 C 风格的基于数组的字符串。

## 多维数组

通常说的多维数组其实是数组的数组。严格的说 C++没有多维数组。

```cpp
int ia[3][4];		// 大小为3的数组 每个数组元素中有4个数组

int arr[10][30][40] = {0};	// 将所有元素初始化为0
// 大小为10的数组 每个数组中有30个数组 这30个数组中每个有40个数组
// 即 总大小为 10*30*40 = 12000 这12000个元素的值都是0
```

对于二维数组，通常把第一个维度称为行，第二个维度称为列

### 多维数组的初始化

示例

```cpp
int ia[3][4] = {
	{0, 1, 2, 3},		// [0][0], [0][1], [0][2], [0][3]
	{4, 5, 6, 7},		// [1][0], [1][1], [1][2], [1][3]
	{8, 9, 10, 11}		// [2][0], [2][1], [2][2], [2][3]
};
```

内层嵌套的`{}`也可以不用，如下代码实现功能与上述完全一致

```cpp
int ia[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11}
```

如下代码，初始化每个行的第一个元素。其余的元素被执行默认值初始化，如果省略`{}`那么效果就变成先初始化第一行元素，若有多的再初始化第二行，再有多就初始化第三行，再多就越界报错。

```cpp
int ia[3][4] = {{0},{4},{8}};
```

### 多维数组的下标引用

可以用下标运算符来访问多维数组的元素,数组的每个维度对应一个下标运算符

```cpp
ia[2][3] = arr[0][0][0];	// 将arr的首元素赋给ia的尾元素
int (&row)[4] = ia[1];		// 把row绑定到ia的第2维度的元素上--> 可以理解为&row引用的是一个长度为4的ia[1]
// [4]表示的是 ia[1]应该有的长度 如果没有 那么编译器就会报错
```

两层嵌套的 for 循环来处理多维数组的元素

```cpp
constexpr size_t rowCnt = 3, colCnt = 4;		// 定义访问数组类型的常量 rowCnt colCnt
int ia[rowCnt][colCnt];		// 12个未初始化的元素
for (size_t i = 0; i != rowCnt; ++i){
    // 对于行内每一列
    for (size_t j = 0; j!= colCnt; ++j){
        // 将元素的位置索引作为它的值
        ia[i][j] = i* colCnt + j;
    }
}
```

### 使用范围 for 语句处理多维数组

C++11 新增的范围 for 语句 所以也可以使用

```cpp
int main(){
    constexpr size_t rowCnt = 3, colCnt = 4;        // 定义访问数组类型的常量 rowCnt colCnt
    int ia[rowCnt][colCnt];     // 12个未初始化的元素

    size_t cnt = 0;
    for (auto &row : ia)
        for (auto col : row)
            cout << col << endl;
    system("pause");
    return 0;
}
```

此处我们不知道应该是用什么类型来表示数组的类型，所以使用 auto。这个循环中没有任何写操作，但是还是将外层的控制变量声明为引用类型，这是为了避免数组被自动转成指针。假设不用引用类型，则循环如下形式

```cpp
for (auto row : ia)
    for (auto col : row)
```

> [!danger] 程序将会无法通过编译
> 像之前一样第一个循环遍历 `ia` 的所有元素，但这些元素实际上是大小为 4 的数组。因为 `row` 不是引用类型，所以编译器初始化 `row` 时候会自动将这些数组形式的元素(和其他类型的数组一样)转换成指向该数组内首元素的指针(`row` 指向 `ia` 当前行的第一个元素)。这样得到的 `row` 的类型就是 `int*`，显然到了里面的循环就不合法了。

### 指针和多维数组

当程序使用多维数组的名字时，也会自动将其转换成指向数组首元素的指针。

因为多维数组实际上是数组的数组，所以由多维数组名转换得到的指针实际上是指向第一个内层数组的指针

```cpp
int ia[3][4];
int (*p)[4] = ia;	// p指向含有4个整数的数组
p = &ia[2];			// p指向ia的第2个维度 也就是指向ia的第2行
```

`*p`是个指针，指向一个维度是 4 的数组，数组中的元素是整数。因此，p 就是指向含有 4 个整数的数组的指针。在其中，圆括号是必不可少的。

C++11 的提出使得我们可以通过 auto 或 decltype 来避免在数组前加上一个指针类型。

```cpp
// 输出ia中每个元素的值 每个内层数组各占一行
// p指向含有4个整数的数组
int ia[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};
for (auto p = ia;p != ia + 3; ++p){					// p的类型为int *[4] 是一个指向长度为4的数组的指针
	// q指向4个整数数组的首元素 也就是说 q指向一个整数
	for (auto q = *p;q != *p + 4; ++q)				// q的类型为int* 是一个指向int的指针
		cout << *q << ' ';
	cout << endl;
}
```

也可以使用标准库函数 begin 和 end

```cpp
int main(){
    constexpr size_t rowCnt = 3, colCnt = 4;        // 定义访问数组类型的常量 rowCnt colCnt
    int ia[rowCnt][colCnt];     // 12个未初始化的元素

    // 输出ia中每个元素的值 每个内层数组各占一行
    // p指向ia的第一个数组
    for (auto p = begin(ia); p != end(ia); ++p){
        // q指向内层数组的首元素
        for (auto q = begin(*p); q != end(*p); ++q)
            cout << *q << ' ';
        cout << endl;
    }
    system("pause");
    return 0;
}
```

在 begin 和 end 这一版本中，循环终止条件由 end 函数负责判断。虽然我们也能推断出 p 的类型是指向含有 4 个整数的数组的指针，q 的类型是指向整数的指针，但是使用 auto 关键字我们就不用再去考虑这些类型到底是什么了。

### 类型别名简化多维数组的指针

使用 [[02 变量和基本类型#类型别名|类型别名]] 能帮助我们读、写、理解一个指向多维数组的指针的工作更加简单。

```cpp
int main(){
    constexpr size_t rowCnt = 3, colCnt = 4;        // 定义访问数组类型的常量 rowCnt colCnt
    int ia[rowCnt][colCnt];     // 12个未初始化的元素

    using int_array = int[4];       // 新标准下类型别名的声明
    typedef int int_array[4];       // 等价的typedef声明

    // 输出ia中每个元素的值 每个内层数组各占一行
    for (int_array *p = ia; p != ia + 3; ++p){
        for (int *q = *p; q != *p + 4; ++q)
            cout << *q << ' ';
        cout << endl;
    }
    system("pause");
    return 0;
}
```

程序将类型"4 个整数组成的数组"命名为 int_array，用类型名 int_array 定义外层循环的控制变量让程序显得简洁明了。
