---
title: 04 表达式
category: 学习
type: 归纳整理
tags:
  - C++学习
  - C++_Primer
  - note
  - 124
---

表达式由一个或者多个**运算对象**(operand)组成，对表达式求值将得到一个**结果**(result)。字面值和变量是最简单的**表达式**(expression)，其结果就是字面值和变量的值。把一个**运算符**(operator)和一个或者多个运算对象组合起来可以生成较复杂的表达式。

## 算术运算符

| 运算符                    | 功能     | 用法          |
| ------------------------- | -------- | ------------- |
| +                         | 一元正号 | `+expr`       |
| -                         | 一元负号 | `-expr`       |
| ∨上方运算符优先级大于下方 | ∨        | ∨             |
| *                         | 乘法     | `expr * expr` |
| /                         | 除法     | `expr / expr` |
| %                         | 求余     | `expr % expr` |
| ∨上方运算符优先级大于下方 | ∨        | ∨             |
| +                         | 加法     | `expr + expr` |
| -                         | 减法     | `expr - expr` |

> [!info] 注
> 1. 除非另做特殊说明，否则算术运算符能做用于任意算术类型以及任意能转换为算术类型的类型。
> 2. 算术运算符的运算对象和求值结果都是右值。
> 3. 一元正号(没有负号)、加减运算符都能作用于指针。一元负号运算符对运算对象值取负之后，返回其提升后的副本。
> 4. 参与取余 `%` 的运算对象必须是整数类型
> 5. 在除法运算中，如果两个运算对象的符号相同则商为正(如果不为 0 的话)，否则商为负。

### 溢出和其他算术运算异常

算术表达式可能产生未定义的结果。一部分原因是数学性质本身：除数是0的情况；另一部分源于计算机的特点：例如溢出，当计算的结果超出该类型所能表示的范围时候就会产生溢出。

``` cpp
short short_value = 32767;
short_value += 1;
cout << short_value << endl;
```

给 `short_value` 赋值的语句是未定义的，这是因为表示一个带符号数32768(32767+1)需要17位，但 short 类型只有16位。很多系统在编译和运行时都不报溢出错误，像其他未定义的行为一样，溢出的结果是不可预知的。

他有可能输出 `-32768cl`,该值发生了"环绕(wrapped around)"，符号位本来是0，由于溢出被改成了1，于是结果变成了一个负值。在别的系统有可能有其他的结果，程序的行为可能不同甚至会导致崩溃。

## 逻辑和关系运算符

下表从上至下是符号优先级。降序排列。

| 结合律 | 运算符       | 功能     | 用法                   |
| ------ | ------------ | -------- | ---------------------- |
| 右     | !            | 逻辑非   | !expr                  | 
| 左     | \<           | 小于     | expr < expr            |
| 左     | <=           | 小于等于 | expr <= expr           |
| 左     | >            | 大于     | expr > expr            |
| 左     | >=           | 大于等于 | expr >= expr           |
| 左     | \==          | 相等     | expr \== expr          |
| 左     | !=           | 不相等   | expr != expr           |
| 左     | &&           | 逻辑与   | expr && expr           |
| 左     | &#124;&#124; | 逻辑或   | expr &#124;&#124; expr |

## 赋值运算符

`=` 赋值运算符左侧必须是个可以被修改的左值。我们也要分清初始化和赋值的不同含义。若 `=` 左右两边的运算对象类型不同，则右侧运算对象的类型就会被转成左侧运算对象的类型。

> [!info] 注
> 1. 赋值运算满足右结合律 `i = j = 0;`
> 2. 赋值运算优先级较低

## 递增和递减运算符

递增 `++` 递减 `--` 运算符为对象的加1和减1提供了一种简写的书写形式。

递增递减运算符有两种形式，一种前置一种后置，如 `i++` 、 `++i`

- 这两种运算符作用对象必须是左值
- 前置版本将对象本身作为左值返回
- 后置版本把对象原始值的副本作为右值返回

> [!danger] 建议：除非是必要的情况，否则就不要用后置版本
> 前置版本的递增运算符避免了不必要的工作，它把值加 1 之后直接返回改变了的运算对象;后置版本需要先将原始值存储下来以便于返回这个还没有被修改过的内容。如果我们不需要修改前的值，那么后置版本的操作就是一种资源浪费。尤其是在复杂的迭代器类型中，这种消耗会是巨大的。

```c++
auto pbeg = v.begin();		// 创建迭代器输出元素直至遇到第一个负值为止
while (pbeg != v.end() && *pbeg >= 0)
    cout << *pbeg++ << endl;
```

## 成员访问运算符

点运算符和箭头运算符都可以用于访问成员。

- 点运算符：获取类对象的一个成员
- 箭头运算符：表达式 `ptr->mem` 也就是 `(*ptr).mem`

> [!info] 注
> 1. 解引用运算符的优先级低于点运算符，所以在使用点运算符的时候要将解引用运算的子表达式括起来
> 2. 箭头运算符作用于一个指针类型的运算对象，结果是个左值。点运算符分成两种情况：
> 	- 若成员所属的对象是左值，那么结果就是左值
> 	- 若成员所属的对象是右值，那么结果就是右值

## 条件运算符

条件运算符`?:`允许我们把简单的`if-else`逻辑嵌入到单个表达式中，条件运算符使用格式

```c++
cond?expr1:expr2;
```

其中 cond 是判断条件的表达式，而 expr1 和 expr2 是两个类型相同或可能转换为某个公共类型的表达式。

执行过程：

1. 求cond的值
2. 若 `cond` 为真则对 expr1 求值并返回该值
3. 若 `cond` 为假则对 expr2 求值并返回该值

