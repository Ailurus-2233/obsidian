---
title: 04 表达式
category: 学习
type: 归纳整理
tags:
  - C++学习
  - C++_Primer
  - note
---

表达式由一个或者多个**运算对象**(operand)组成，对表达式求值将得到一个**结果**(result)。字面值和变量是最简单的**表达式**(expression)，其结果就是字面值和变量的值。把一个**运算符**(operator)和一个或者多个运算对象组合起来可以生成较复杂的表达式。

## 运算符

### 算术运算符

| 运算符 | 功能     | 用法          |
| ------ | -------- | ------------- |
| +      | 一元正号 | `+expr`       |
| -      | 一元负号 | `-expr`       |
| \*     | 乘法     | `expr * expr` |
| /      | 除法     | `expr / expr` |
| %      | 求余     | `expr % expr` |
| +      | 加法     | `expr + expr` |
| -      | 减法     | `expr - expr` |

> [!info] 注
>
> 1. 除非另做特殊说明，否则算术运算符能做用于任意算术类型以及任意能转换为算术类型的类型。
> 2. 算术运算符的运算对象和求值结果都是右值。
> 3. 一元正号(没有负号)、加减运算符都能作用于指针。一元负号运算符对运算对象值取负之后，返回其提升后的副本。
> 4. 参与取余 `%` 的运算对象必须是整数类型
> 5. 在除法运算中，如果两个运算对象的符号相同则商为正(如果不为 0 的话)，否则商为负。

#### 溢出和其他算术运算异常

算术表达式可能产生未定义的结果。一部分原因是数学性质本身：除数是 0 的情况；另一部分源于计算机的特点：例如溢出，当计算的结果超出该类型所能表示的范围时候就会产生溢出。

```cpp
short short_value = 32767;
short_value += 1;
cout << short_value << endl;
```

给 `short_value` 赋值的语句是未定义的，这是因为表示一个带符号数 32768(32767+1)需要 17 位，但 short 类型只有 16 位。很多系统在编译和运行时都不报溢出错误，像其他未定义的行为一样，溢出的结果是不可预知的。

他有可能输出 `-32768cl`,该值发生了"环绕(wrapped around)"，符号位本来是 0，由于溢出被改成了 1，于是结果变成了一个负值。在别的系统有可能有其他的结果，程序的行为可能不同甚至会导致崩溃。

### 逻辑和关系运算符

下表从上至下是符号优先级。降序排列。

| 结合律 | 运算符       | 功能     | 用法                   |
| ------ | ------------ | -------- | ---------------------- |
| 右     | !            | 逻辑非   | !expr                  |
| 左     | \<           | 小于     | expr < expr            |
| 左     | <=           | 小于等于 | expr <= expr           |
| 左     | >            | 大于     | expr > expr            |
| 左     | >=           | 大于等于 | expr >= expr           |
| 左     | \==          | 相等     | expr \== expr          |
| 左     | !=           | 不相等   | expr != expr           |
| 左     | &&           | 逻辑与   | expr && expr           |
| 左     | &#124;&#124; | 逻辑或   | expr &#124;&#124; expr |

### 赋值运算符

`=` 赋值运算符左侧必须是个可以被修改的左值。我们也要分清初始化和赋值的不同含义。若 `=` 左右两边的运算对象类型不同，则右侧运算对象的类型就会被转成左侧运算对象的类型。

> [!info] 注
>
> 1. 赋值运算满足右结合律 `i = j = 0;`
> 2. 赋值运算优先级较低

### 递增和递减运算符

递增 `++` 递减 `--` 运算符为对象的加 1 和减 1 提供了一种简写的书写形式。

递增递减运算符有两种形式，一种前置一种后置，如 `i++` 、 `++i`

- 这两种运算符作用对象必须是左值
- 前置版本将对象本身作为左值返回
- 后置版本把对象原始值的副本作为右值返回

> [!danger] 建议：除非是必要的情况，否则就不要用后置版本
> 前置版本的递增运算符避免了不必要的工作，它把值加 1 之后直接返回改变了的运算对象;后置版本需要先将原始值存储下来以便于返回这个还没有被修改过的内容。如果我们不需要修改前的值，那么后置版本的操作就是一种资源浪费。尤其是在复杂的迭代器类型中，这种消耗会是巨大的。

```cpp
auto pbeg = v.begin();		// 创建迭代器输出元素直至遇到第一个负值为止
while (pbeg != v.end() && *pbeg >= 0)
    cout << *pbeg++ << endl;
```

### 成员访问运算符

点运算符和箭头运算符都可以用于访问成员。

- 点运算符：获取类对象的一个成员
- 箭头运算符：表达式 `ptr->mem` 也就是 `(*ptr).mem`

> [!info] 注
>
> 1. 解引用运算符的优先级低于点运算符，所以在使用点运算符的时候要将解引用运算的子表达式括起来
> 2. 箭头运算符作用于一个指针类型的运算对象，结果是个左值。点运算符分成两种情况：
>    - 若成员所属的对象是左值，那么结果就是左值
>    - 若成员所属的对象是右值，那么结果就是右值

### 条件运算符

条件运算符`?:`允许我们把简单的`if-else`逻辑嵌入到单个表达式中，条件运算符使用格式

```cpp
cond ? expr1 : expr2;
```

其中 cond 是判断条件的表达式，而 expr1 和 expr2 是两个类型相同或可能转换为某个公共类型的表达式。

执行过程：

1. 求 cond 的值
2. 若 `cond` 为真则对 expr1 求值并返回该值
3. 若 `cond` 为假则对 expr2 求值并返回该值

### 位运算符

位运算符作用于整数类型的运算对象，并把运算对象看成是二进制位的集合。位运算符提供检查和设置二进制位的功能。第 17 章会介绍一种名为`bitset`的标准库类型也可以表示任意大小的二进制位集合，所以位运算符同样能用于`bitset`类型。

| 运算符 | 功能   | 用法             | 说明                                         |
| ------ | ------ | ---------------- | -------------------------------------------- |
| &#126; | 位求反 | &#126;expr       | 按位取反                                     |
| <<     | 左移   | expr1 << expr2   | 向左移动右侧补 0，超过边界的数被舍弃         |
| >>     | 右移   | expr1 >> expr2   | 向右移动左侧补符号位或 0，超过边界的数被舍弃 |
| &      | 位与   | expr & expr      | 按位计算，如果都是 1 那么结果是 1 否则是 0   |
| &#94;  | 位异或 | expr &#94; expr  | 按位计算，如果位不一致，结果是 1 否则是 0    |
| &#124; | 位或   | expr &#124; expr | 按位计算，如果都是 0 那么结果是 0，否则是 1  |

### sizeof 运算符

`sizeof` 运算符返回一条表达式或者一个类型名字所占的字节数。`sizeof` 运算符满足右结合律，其所得的值是个`size_t`类型的常量表达式。

`sizeof`运算符的结果部分依赖于其作用的类型：

- 对`char`或者类型为`char`的表达式执行`sizeof`运算，结果得 1
- 对引用类型执行`sizeof`运算得到被引用对象所占空间的大小
- 对指针执行`sizeof`运算得到指针本身所占空间的大小
- 对解引用指针执行`sizeof`运算得到指针指向的对象所占用空间的大小，指针无需有效。
- 对数组执行`sizeof`运算得到整个数组所占用空间的大小，也就是对数组中的每个元素执行一次`sizeof`运算并把所有结果求和。`sizeof`不会把数组转成指针处理
- 对`string`对象或`vector`对象执行`sizeof`运算只会返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间

### 逗号运算符

**逗号运算符**(comma operator)含有两个运算对象，按照从左向右的顺序依次求值。和逻辑与、逻辑或、条件运算符一样，逗号运算符也规定了运算对象求值的顺序。

逗号运算符先算左侧的表达式，然后把左侧表达式的结果丢掉。逗号运算符真正的结果是右侧表达式的值。若右侧对象是左值，那么最终的求值结果也是左值

```cpp
vector<int>::size_type cnt = ivec.size();
for(vector<int>::size_type ix = 0; ix != ivec.size(); ++ix, --cnt)
	ivec[ix] = cnt;
```

## 类型转换

如果两种类型可以**相互转换**(conversion)，那么它们就是关联的。两个运算对象类型不同。C++语言不会直接把两个不同类型的值相加，会根据类型转换规则设法把运算对象的类型统一之后再求值，这一类型转换是自动执行的，它们被称为**隐式转换**(implicit conversion)。

### 何时发生隐式类型转换

下列情况中，编译器会自动转换运算对象的类型

- 在大多数表达式中，比 int 类型小的整型值首先被提升成较大的整数类型
- 在条件中，非布尔类型转换成布尔类型
- 初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型
- 如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型
- 后面将会提到，函数调用时侯也会发生类型转换

### 算术转换

**算术转换** (arithmetic conversion)的含义是把一种算术类型转换成另外一种算术类型。普遍情况下，会被转成较宽的类型。当表达式中既有浮点类型也有整数类型时候，整数值将转换成相应的浮点类型。

#### 整型提升

**整型提升**(integral promotion)负责把小整数类型转换成较大的整数类型。于`bool`、`char`、`signed char`、`unsigned char`、`short`等类型而言，只要它们的值可以存在`int`中，就会被提升成`int`。提升的前提是转换后的类型要能够容纳原类型所有可能的值。

#### 无符号类型的运算对象

若某个运算符的运算对象类型不一致，那就会被转成同一种类型。但是如果某个运算对象的类型是无符号类型，那么转换的结果就依赖于机器中各个整数类型的相对大小了。

如果两个运算对象的类型大小相同，但是一个有符号一个无符号，那么有符号就会被转成无符号。若有符号类型的值刚好是负值，那么就会取模。即表示数值总数取模后的余数。

若两个运算对象中，有符号类型比无符号类型的大，那么转换结果依赖于机器。若无符号类型的所有值能存在该带符号类型中，则无符号类型的运算对象转换成带符号类型。如果不能，那么带符号类型的运算对象转换成无符号类型。

例如，`long`和`unsigned int`，`unsigned int`和`long`的大小相同，则`long`类型的运算对象转成`unsigned int`类型；但是若`long`类型的对象占用空间比`unsigned int`大，则`unsigned int`类型的运算对象转换成`long`类型。

### 其它隐式类型转换

**数组转换成指针**：在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针

```cpp
int ia[10];
int* ip = la;		// ia转成指向数组首元素的指针
```

当数组被用作`decltype`关键字的参数，或者作为取地址符`&`、`sizeof`等运算符的运算对象时，上述转换不会发生。同样的，如果用一个引用来初始化数组，上述转换也不会发生(实际上不可以用引用来初始化数组)。

**指针的转换**：C++规定几种其他的指针转换方式，包括：

- 常量整数值 0 或者字面值 `nullptr` 能转换成任意指针类型；
- 指向任意非常量的指针能转换成`void*`；
- 指向任意对象的指针能转换成`const void*`

**转换成布尔类型**：存在一种从算术类型或指针类型向布尔类型自动转换的机制。如果指针或算术类型的值为 0，结果为 false，否则 true：

```cpp
char *cp = get_string();
if (cp) /*...*/		// 若指针cp不是空指针(指向0) 条件为真
while(*cp) /*...*/	// 若*cp不是空字符 条件为真
```

**转换成常量**：允许将指向非常量类型的指针转换成指向相应的常量类型的指针，对于引用也是如此。

也就是说，若 T 是一种类型，那么我们就能把指向 T 的指针或者引用分别转换成指向 const T 的指针或者引用：

```cpp
int i;
const int &j = i;		// 非常量转换成const int的引用
const int *p = &i;		// 非常量的地址转换成const的地址
in &r = j, *q = p;		// 错误 不允许将const转成非常量
```

相反的转换不存在，也就是说已经是 const 常量的不能再转成变量，即不能删除底层 const。

**类类型定义的转换**：类类型能定义由编译器自动执行的转换，不过编译器每次只能执行一种类类型的转换。如果同时提出多个转换请求，那么这些请求会被拒绝。

已经使用过类类型转换：

```cpp
string s, t = "a value";		// 字符串字面值转换成string类型
while (cin >> s)			   //  while的条件部分把cin转换成布尔值
```

IO 库定义了从 iostream 向布尔值转换的规则，根据该规则，cin 自动转换成布尔值。所得的布尔值到底是啥由输入流的状态决定。

### 显式转换

有时我们希望显示地把对象强制转成另外一种类型。

```cpp
int i, j;
double slope = i/j;
```

就要使用某种方法将 i 和 j 显式地转换成 double，这种方法称为**强制类型转换**

#### 命名的强制类型转换

```cpp
cast-name<type>(expression);
```

其中，`type`是转换得目标类型而`expression`是要转换的值。若`type`是引用类型，则结果是左值。

`cast-name`是`static_cast`、`dynamic_cast`、`const_cast`、`reinterpret_cast`中的一种。`dynamic_cast`支持运行时类型识别。`cast-name`制定了执行的是哪种转换。

##### static_cast

任何具有明确定义的类型转换，只要不包含底层`const`，都可以使用`static_cast`。

例如，将一个运算对象强制转成 double 类型就能使得表达式执行浮点数除法：

```cpp
double slope = static_cast<double>(j) / i;
```

常用于把一个较大的算术类型赋值给较小的类型时。通常如果编译器发现一个较大的算术类型试图赋值给较小的类型，就会给出警告信息，但如果用了显示转换，便是表明我们不在乎精度损失，警告就没了。

`static_cast`对于编译器无法自动执行的类型转换也很有用。可以用它来找回存在于`void*`的指针中的值

```cpp
void* p = &d;		                    // 正确 任何非常量对象的地址都能存入void*
double *dp = static_cast<double*>(p);	// 将void*转回初始的指针类型
```

强制转换的结果会与原来的地址值相同，所以我们必须确保转换后所得到的类型就是指针所指的类型，就上述代码看，`&d`原先得是`double`类型。类型不符，就导致意想不到的后果。

##### const_cast

`const_cast`只能改变对象的底层`const`。且也只有`const_cast`能改变对象的底层`const`。

```cpp
const char *pc;
char *p = const_cast<char*>(pc);		// 正确 但是通过p写值是未定义的行为
```

将常量对象转成非常量的行为称为"去掉`const`性质(cast away the const)"。一旦我们去掉了某个对象的 const 性质，编译器就不会再阻止我们对这个对象进行写操作了。

如果对象本身不是一个常量，使用强制类型转换获得写权限是合法的行为。如果对象是个常量，再用`const_cast`执行写操作就会产生未定义的行为。`const_cast`常用于有函数重载的上下文中。

##### reinterpret_cast

`reinterpret_cast`通常为运算对象的位模式提供较低层次上的重新解释。示例如下：

```cpp
int *ip;
char *pc = reinterpret_cast<char*>(ip);
```

`pc`所指是个数字而不是字符，若把`pc`当成普通的字符指针使用就可能在运行时候发生错误：

```cpp
 string str(pc);
```

使用`reinterpret_cast`是很危险的，用`pc`初始化`str`的例子很好地证明了这一点。其中的关键问题是类型改变了，但编译器没有给出任何警告或者错误的提示信息，编译器认为这种显式的转换是合法的。上述例子中虽然用`pc`初始化`str`没什么实际意义，甚至可能引发严重的后果，但是从语法上说这种操作也没什么。查找这类问题很难，若将`ip`转换成`pc`的语句和用`pc`初始化`string`对象的语句分属在不同的文件就更加查出问题了。

**`reinterpret_cast`本质上依赖于机器。要想安全地使用`reinterpret_cast`必须对涉及的类型和编译器实现转换的过程都非常了解。**
