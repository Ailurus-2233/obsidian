---
title: 高并发场景下，怎么保证数据的一致性的
draft: false
categroy: 学习
type: 归纳整理
tags:
  - 软件设计
  - 软件工程
date: 2023-11-29
---

## 简述

高并发的场景下，往往需要缓存数据库+实际数据库来减轻数据库的检索压力，加快查询效率。然而一份数据存储在两个地方，更新数据的时候，往往会出现数据不一致的情况，比如实际数据库更新了数据，但是缓存数据库没有更新等等，所以这时候设计逻辑就需要考虑到数据库更新时的流程。

整理一下，可以描述为
一致性就是数据保持一致，在分布式系统中，可以理解为多个节点中数据的值是一致的。

**强一致性**：这种一致性级别是最符合用户直觉的，它要求系统写入什么，读出来的也会是什么，用户体验好，但实现起来往往对系统的性能影响大
**弱一致性**：这种一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的值，也不承诺多久之后数据能够达到一致，但会尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态
**最终一致性**：最终一致性是弱一致性的一个特例，系统会保证在一定时间内，能够达到一个数据一致的状态。这里之所以将最终一致性单独提出来，是因为它是弱一致性中非常推崇的一种一致性模型，也是业界在大型分布式系统的数据一致性上比较推崇的模型

保证数据一致性，一般有这4种方法：

1. 先更新缓存，再更新数据库。
2. 先更新数据库，再更新缓存。
3. 先删除缓存，再更新数据库。
4. 先更新数据库，再删除缓存。
## 一般情况分析
### 1 先更新缓存，再更新数据库：

如果同时来了两个并发写请求，执行过程是这样的：

1. 写请求1更新缓存，设置值为1
2. 写请求2更新缓存，设置值为2
3. 写请求2更新数据库，设置值为2
4. 写请求1更新数据库，设置值为1

执行结果就是，缓存里值被设置2，数据库里的值被设置成1，导致数据不一致，此方案不可行。

### 2 先更新数据库，再更新缓存

如果同时来了两个并发写请求，执行过程是这样的：

1. 写请求1更新数据库，设置值为1
2. 写请求2更新数据库，设置值为2
3. 写请求2更新缓存，设置值为2
4. 写请求1更新缓存，设置值为1

执行结果就是，数据库里值被设置2，缓存里的值被设置成1，导致数据不一致，此方案不可行。

### 3 先删除缓存，再更新数据库

如果同时来了两个并发读写请求，执行过程是这样的：

1. 写请求删除了缓存
2. 读请求查询缓存没数据，然后查询数据库，再把数据写到缓存中
3. 写请求更新数据库

执行结果是，缓存中是旧数据，而数据库里是新数据，导致数据不一致，此方案不可行。

### 4 先更新数据库，再删除缓存

这种方案，在并发写的时候，不会出问题。因为都是先更新数据库再删除缓存，不会出现不一致的情况。

但是在并发读写的时候，还是有可能出现数据不一致。

1. 读请求查询缓存没数据，然后查询数据库
2. 写请求更新数据库，删除缓存
3. 读请求回写缓存

执行结果是，缓存中是旧数据，而数据库里是新数据，导致数据不一致。但其实这种情况出现的概率很低，写缓存比写数据库快出几个量级，读写缓存都是内存操作，速度非常快。遇到了这种极端场景，我们也需要做一下兜底方案，缓存都要设置过期时间。这种方案属于数据的弱一致性和最终一致性，而不是强一致性。

