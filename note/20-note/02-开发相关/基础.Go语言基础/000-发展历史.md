简单记录一下Go的历史以及与其他语言的异同与优劣势

# 发展历史

## 设计起因

Go 语言的创始人有三位，分别是图灵奖获得者、C 语法联合发明人、Unix 之父**肯·汤普森（Ken Thompson）**，Plan 9 操作系统领导者、UTF-8 编码的最初设计者**罗伯·派克（Rob Pike）**，以及 Java 的 HotSpot 虚拟机和 Chrome 浏览器的 JavaScript V8 引擎的设计者之一**罗伯特·格瑞史莫（Robert Griesemer）**

当时的谷歌内部主要使用 C++ 语言构建各种系统，但 C++ 的巨大复杂性、编译构建速度慢以及在编写服务端程序时对并发支持的不足，让三位大佬觉得十分不便，他们就想着设计一门新的语言。在他们的初步构想中，这门新语言应该是能够给程序员带来快乐、匹配未来硬件发展趋势并适合用来开发谷歌内部大规模网络服务程序的。

Go语言的初步设计思路是，在 C 语言的基础上，修正一些明显的缺陷，删除一些被诟病较多的特性，增加一些缺失的功能，比如，使用 import 替代 include、去掉宏、增加垃圾回收、支持接口等。

## 时间线

* **2008 年** 年初，Unix 之父肯·汤普森实现了第一版 Go 编译器，用于验证之前的设计。这个编译器先将 Go 代码转换为 C 代码，再由 C 编译器编译成二进制文件；年中，同样在谷歌工作的伊恩·泰勒（Ian Lance Taylor）为 Go 语言实现了一个 gcc 的前端，这也是 Go 语言的第二个编译器，伊恩·泰勒以团队的第四位成员的身份正式加入 Go 语言开发团队，后面也成为了 Go 语言，以及其工具设计和实现的核心人物之一；罗斯·考克斯（Russ Cox）是 Go 核心开发团队的第五位成员，进入团队后，罗斯·考克斯利用函数类型是“一等公民”，设计出了 http 包的HandlerFunc类型，并在当时设计的基础上提出了一些更泛化的想法，比如io.Reader和io.Writer接口
* **2009 年** 11 月 10 日，谷歌官方宣布 Go 语言项目开源，之后这一天也被 Go 官方确定为 Go 语言的诞生日。
* **2012 年** 3 月 28 日 Go 1.0 版本正式发布，同时 Go 官方发布了“Go 1 兼容性”承诺：只要符合 Go 1 语言规范的源代码，Go 编译器将保证向后兼容（backwards compatible），也就是说我们使用新版编译器也可以正确编译用老版本语法编写的代码。

![时间线](timeline.png)

## go语言现状

如今的 Go 语言已经逐渐成为了**云计算时代基础设施的编程语言**。你能想到的现代云计算基础设施软件的大部分流行和可靠的作品，都是用 Go 编写的，比如：Docker、Kubernetes、Prometheus、Ethereum（以太坊）、Istio、CockroachDB、InfluxDB、Terraform、Etcd、Consul

Go 除了在云计算基础设施领域，拥有上面这些杀手级应用之外，Go 语言的用户数量也在近几年快速增加。Go 语言项目技术负责人罗斯·考克斯甚至还专门写过一篇文章，来估算全世界范围的 Gopher 数量。按照他的估算结果，全世界范围的 Gopher 数量从 2017 年年中的最多 100 万，增长到 2019 年 11 月的最多 196 万，大概两年半翻了一番。庞大的 Gopher 基数为 Go 未来的发展提供持续的增长潜力和更大的想象空间。

# go的设计哲学

## 简单

“简单”，就意味着 Go 不会像 C++、Java 那样将其他编程语言的新特性兼蓄并收，所以你在 Go 语言中看不到传统的面向对象的类、构造函数与继承，看不到结构化的异常处理，也看不到本属于函数编程范式的语法元素。其实，Go 语言也没它看起来那么简单，自身实现起来并不容易，但这些复杂性被 Go 语言的设计者们“隐藏”了，所以 Go 语法层面上呈现了这样的状态：

* 仅有 25 个关键字，主流编程语言最少；
* 内置垃圾收集，降低开发人员内存管理的心智负担；
* 首字母大小写决定可见性，无需通过额外关键字修饰；
* 变量初始为类型零值，避免以随机值作为初值的问题；
* 内置数组边界检查，极大减少越界访问带来的安全隐患；
* 内置并发支持，简化并发程序设计；
* 内置接口类型，为组合的设计哲学奠定基础；
* 原生提供完善的工具链，开箱即用；
* ...

简单意味着可以使用更少的代码实现相同的功能；简单意味着代码具有更好的可读性，而可读性好的代码通常意味着更好的可维护性以及可靠性。总之，在软件工程化的今天，这些都意味着对生产效率提升的极大促进，我们可以认为简单的设计哲学是 Go 生产力的源泉。

## 显示

Go 不允许不同类型的整型变量进行混合计算，它同样也不会对其进行隐式的自动转换，因此对于以下c代码

```c++
int main() { 
    short int a = 5; 
    int b = 8; 
    long c = 0; 
    c = a + b; 
    printf("%ld\n", c);
}
```

对于go来说就需要，多一步显示转换的操作

``` go
import "fmt"

func main() {
    var a int16 = 5
    var b int = 8
    var c int64

    c = int64(a) + int64(b)
    fmt.Printf("%d\n", c)
}
```

在 Go 语言中，不同类型变量是不能在一起进行混合计算的，这是因为 Go 希望开发人员明确知道自己在做什么,除此之外，Go 设计者所崇尚的显式哲学还直接决定了 Go 语言错误处理的形态：Go 语言采用了显式的基于值比较的错误处理方案，函数 / 方法中的错误都会通过 return 语句显式地返回，并且通常调用者不能忽略对返回的错误的处理。

## 组合

这个设计哲学和我们各个程序之间的耦合有关，Go没有选择经典的面向对象语法元素、类型体系和继承机制，而推崇的是组合的设计哲学。

在 Go 语言设计层面，Go 设计者为开发者们提供了正交的语法元素，以供后续组合使用，包括：

* Go 语言无类型层次体系，各类型之间是相互独立的，没有子类型的概念；
* 每个类型都可以有自己的方法集合，类型定义与方法实现是正交独立的；
* 实现某个接口时，无需像 Java 那样采用特定关键字修饰；
* 包之间是相对独立的，没有子包的概念。

我们可以看到，无论是包、接口还是一个个具体的类型定义，Go 语言其实是为我们呈现了这样的一幅图景：一座座没有关联的“孤岛”，但每个岛内又都很精彩。那么现在摆在面前的工作，就是在这些孤岛之间以最适当的方式建立关联，并形成一个整体。而 Go 选择采用的组合方式，也是最主要的方式。

Go 语言为支撑组合的设计提供了类型嵌入（Type Embedding）,TB老师课程中，把他称之为垂直组合，采用嵌入方式定义的新类型继承了嵌入类型的能力，如下代码
```go
type poolLocal struct {
    private interface{}   
    shared  []interface{}
    Mutex               
    pad     [128]byte  
}
```
在代码段中，我们在 poolLocal 这个结构体类型中嵌入了类型 Mutex，这就使得 poolLocal 这个类型具有了互斥同步的能力，我们可以通过 poolLocal 类型的变量，直接调用 Mutex 类型的方法 Lock 或 Unlock。

另外，我们在标准库中还会经常看到类似如下定义接口类型的代码段：
```go
type ReadWriter interface {
    Reader
    Writer
}
```
这里，标准库通过嵌入接口类型的方式来实现接口行为的聚合，组成大接口，这种方式在标准库中尤为常用，并且已经成为了 Go 语言的一种惯用法。

Go 还有一种常见的组合方式，叫水平组合。和垂直组合的能力继承不同，水平组合是一种能力委托（Delegate），我们通常使用接口类型来实现水平组合。水平组合的模式有很多，比如一种常见方法就是，通过接受接口类型参数的普通函数进行组合，如以下代码段所示：

``` go
// $GOROOT/src/io/ioutil/ioutil.go
func ReadAll(r io.Reader)([]byte, error)

// $GOROOT/src/io/io.go
func Copy(dst Writer, src Reader)(written int64, err error)
```
也就是说，函数 ReadAll 通过 io.Reader 这个接口，将 io.Reader 的实现与 ReadAll 所在的包低耦合地水平组合在一起了，从而达到从任意实现 io.Reader 的数据源读取所有数据的目的。

总之，组合原则的应用实质上是塑造了 Go 程序的骨架结构。类型嵌入为类型提供了垂直扩展能力，而接口是水平组合的关键，它好比程序肌体上的“关节”，给予连接“关节”的两个部分各自“自由活动”的能力，而整体上又实现了某种功能。并且，组合也让遵循“简单”原则的 Go 语言，在表现力上丝毫不逊色于其他复杂的主流编程语言。

## 并发

2007 年开始，处理器厂商的竞争焦点从主频转向了多核，在这种大背景下，Go 的设计者在决定去创建一门新语言的时候，果断将面向多核、原生支持并发作为了新语言的设计原则之一。并且，Go 放弃了传统的基于操作系统线程的并发模型，而采用了用户层轻量级线程，Go 将之称为 goroutine。

goroutine 优势：

1. goroutine 占用的资源非常小，Go 运行时默认为每个 goroutine 分配的栈空间仅 2KB。goroutine 调度的切换也不用陷入（trap）操作系统内核层完成，代价很低。
2. Go 还在语言层面内置了辅助并发设计的原语：channel 和 select。开发者可以通过语言内置的 channel 传递消息或实现同步，并通过 select 实现多路 channel 的并发控制。

并发与组合的哲学是一脉相承的，并发是一个更大的组合的概念，它在程序设计的全局层面对程序进行拆解组合，再映射到程序执行层面上：goroutines 各自执行特定的工作，通过 channel+select 将 goroutines 组合连接起来。并发的存在鼓励程序员在程序设计时进行独立计算的分解，而对并发的原生支持让 Go 语言也更适应现代计算环境。

## 面向工程

Go 语言设计的初衷，就是面向解决真实世界中 Google 内部大规模软件开发存在的各种问题，为这些问题提供答案，这些问题包括：程序构建慢、依赖管理失控、代码难于理解、跨语言构建难等。

语法是编程语言的用户接口，它直接影响开发人员对于这门语言的使用体验。在面向工程设计哲学的驱使下，Go 在语法设计细节上做了精心的打磨。比如：

* 重新设计编译单元和目标文件格式，实现 Go 源码快速构建，让大工程的构建时间缩短到类似动态语言的交互式解释的编译速度；
* 如果源文件导入它不使用的包，则程序将无法编译。这可以充分保证任何 Go 程序的依赖树是精确的。这也可以保证在构建程序时不会编译额外的代码，从而最大限度地缩短编译时间；
* 去除包的循环依赖，循环依赖会在大规模的代码中引发问题，因为它们要求编译器同时处理更大的源文件集，这会减慢增量构建；
* 包路径是唯一的，而包名不必唯一的。导入路径必须唯一标识要导入的包，而名称只是包的使用者如何引用其内容的约定。“包名称不必是唯一的”这个约定，大大降低了开发人员给包起唯一名字的心智负担；
* 故意不支持默认函数参数。因为在规模工程中，很多开发者利用默认函数参数机制，向函数添加过多的参数以弥补函数 API 的设计缺陷，这会导致函数拥有太多的参数，降低清晰度和可读性；
* 增加类型别名（type alias），支持大规模代码库的重构。

在标准库方面，Go 被称为“自带电池”的编程语言。如果说一门编程语言是“自带电池”，则说明这门语言标准库功能丰富，多数功能不需要依赖外部的第三方包或库，Go 语言恰恰就是这类编程语言。Go 在标准库中提供了各类高质量且性能优良的功能包，其中的net/http、crypto、encoding等包充分迎合了云原生时代的关于 API/RPC Web 服务的构建需求，

Go 语言就提供了足以让所有其它主流语言开发人员羡慕的工具链，工具链涵盖了编译构建、代码格式化、包依赖管理、静态代码检查、测试、文档生成与查看、性能剖析、语言服务器、运行时程序跟踪等方方面面。

在提供丰富的工具链的同时，Go 在标准库中提供了官方的词法分析器、语法解析器和类型检查器相关包，开发者可以基于这些包快速构建并扩展 Go 工具链。

## 总结

在这一讲中，我和你一起了解了 Go 语言的设计哲学：简单、显式、组合、并发和面向工程。

* 简单 是指 Go 语言特性始终保持在少且足够的水平，不走语言特性融合的道路，但又不乏生产力。简单是 Go 生产力的源泉，也是 Go 对开发者的最大吸引力；
* 显式 是指任何代码行为都需开发者明确知晓，不存在因“暗箱操作”而导致可维护性降低和不安全的结果；
* 组合 是构建 Go 程序骨架的主要方式，它可以大幅降低程序元素间的耦合，提高程序的可扩展性和灵活性；
* 并发 是 Go 敏锐地把握了 CPU 向多核方向发展这一趋势的结果，可以让开发人员在多核时代更容易写出充分利用系统资源、支持性能随 CPU 核数增加而自然提升的应用程序；
* 面向工程 是 Go 语言在语言设计上的一个重大创新，它将语言要解决的问题域扩展到那些原本并不是由编程语言去解决的领域，从而覆盖了更多开发者在开发过程遇到的“痛点”，为开发者提供了更好的使用体验。



