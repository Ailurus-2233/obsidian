# 任务目标

使用框架工具，配置硬件相关的配置文件，包括生成欧姆龙PLC的dll，配置轴等硬件，配置plc_config这些步骤。

# 操作步骤

## 1 安装MwFramework.DeviceModule

安装完成后，拷贝`packages/MwFramework.DeviceModule/tools`目录下的文件到输出目录，其中`DeviceModules`文件夹是存放各种驱动dll，其实只需要拷贝指定的硬件的dll即可，而且这个dll不一定是硬件实际需要的，具体使用时需要替换为实际使用的dll。

## 2 **添加Omron控制卡**

常用的控制卡为Omron控制卡，所以下面的演示以添加Omron控制卡为示例，这时需要拿到一个电气提供的表格文件。

### 2.1 安装 MwFramework.OmronPLCDriver

将`packages/MwFramework.OmronPLCDriver.1.0.2.1/`目录下的Configuration文件夹拷贝到输出目录

### 2.2 将**欧姆龙PLC_Tag_Map表转化为dll**

1. 拷贝表格文件到输出目录的`Configuration/OmronConfig`文件下，执行ConfigTool.exe，双击左侧的PLC1Module，当然也可以新建一个。
	![](https://cdn.jsdelivr.net/gh/Ailurus-2233/PicGo-ImageRepo@main/work-Image/202308281100530.png.png)
2. PLC Config需要根据具体情况来配置，但是如果时Demo环境的话，可以不用配置相关的信息，点击清空选择的表格，然后选择对应的表格→开始配置→生成所有Excel，不出意外的会提示dll生成成功，生成的路径在输出目录。文件名是`MaxWellOrmonPlcData.dll`

### 2.3 配置plc_config.txt

version1的配置说明[[plc_config version1]]

1. clone下面配置程序到项目目录中
    [nas.maxwell-gp.com.cn](http://nas.maxwell-gp.com.cn:4995/Zzy/configgenerator)
2. 对应表格完成程序编写
    1. 查找轴的数量和点位的数量，一般在表格文件的AXIS_STATUS表格和AxisMotionPara表格，其中的数组长度即为轴的数量和点位的数量

        ```csharp
        //点位模块定义
        PosDefination pd = new PosDefination()
        {
            AxisIDStart = 0,
            AxisIDEnd = 63,
            PosIDStart = 0,
            PosIDEnd = 15,
        };
        ```

        其中AxisID的0和63对应AXIS_STATUS表格中Data_Type中ARRAY的长度

        | Tag_Name        | Event_Name                   | Item_Name              | Data_Type                        |
        | --------------- | ---------------------------- | ---------------------- | -------------------------------- |
        | MFC_AXIS_STATUS | MFC_AXIS_STATUS_Struct_Block | ListOfAxisStatusStruct | ARRAY[0..63] OF AxisStatusStruct |

        PosID的和15对应AxisMotionPara表格中Data_Type中ARRAY的长度

        | Item_Name | Data_Type            |
        | --------- | -------------------- |
        | Pos       | ARRAY[0..15] OF REAL |
        | Vel       | ARRAY[0..15] OF REAL |

    2. 设定轴命令、状态、点位位置和速度的格式

        ```csharp
        pd.SetAxisCommand(() => OrmonDataManager.MFC_AXIS_CMD.MFC_AXIS_CMD_Struct_Block.ListOfAxisCMDStruct);
        pd.SetAxisState(() => OrmonDataManager.MFC_AXIS_STATUS.MFC_AXIS_STATUS_Struct_Block.ListOfAxisStatusStruct);
        pd.SetPosition(() => OrmonDataManager.MFC_AXIS_MotionPAR.MFC_AXIS_MotionPAR_Struct_Block.ListOfAxisMotionPara[0].Pos_0);
        pd.SetVelocity(() => OrmonDataManager.MFC_AXIS_MotionPAR.MFC_AXIS_MotionPAR_Struct_Block.ListOfAxisMotionPara[0].Vel_0);
        ```

        其中AxisCommand中后面一长串的结构具体在AXIS_CMD表格

        | Tag_Name     | Event_Name                | Item_Name           |
        | ------------ | ------------------------- | ------------------- |
        | MFC_AXIS_CMD | MFC_AXIS_CMD_Struct_Block | ListOfAxisCMDStruct |

        根据`Tag_Name.Event_Name.Item_Name`来选择具体描述Command的格式，State的同理，在AXIS_STATUS表格中查找对应的结构。而对于点位和速度通常在AXIS_MotionPAR中，同样使用之前的结构选择对应列表，只不过需要选择Pos_0和Vel_0

    3. 配置轴点位

        ```csharp
        pd.AddPosition(2, 0, "FineAlign1Y1_待机点");
        pd.AddPosition(2, 1, "FineAlign1Y1_Mark1点");
        pd.AddPosition(2, 2, "FineAlign1Y1_Mark2点");
        plcConfig.Append(pd);
        ```

        | Axis_FineAlign1Y1_Pos | FineAlign1Y1_待机点  | MFC_AXIS_MotionPAR.Axis[2].Pos[0] |
        | --------------------- | -------------------- | --------------------------------- |
        |                       | FineAlign1Y1_Mark1点 | MFC_AXIS_MotionPAR.Axis[2].Pos[1] |
        |                       | FineAlign1Y1_Mark2点 | MFC_AXIS_MotionPAR.Axis[2].Pos[2] |

        轴点位在MotionParaInfo表格中，名称是第二列的名称，前面的2，0标识第二个轴的第0个点位，一一对应的关系如上表和代码，需要将表格所有的点位写进去。

    4. IO模块定义

        ```csharp
        IODefination iod = new IODefination() { IOIDStart = 0, IOIDEnd = 255 };
        iod.SetBoolIOCmd(() => OrmonDataManager.MFC_CMD.MFC_CMD_Struct_Block.TP_0);
        iod.SetBoolIOState(() => OrmonDataManager.MFC_STATUS.MFC_STATUS_Struct_Block.TL_0);
        ```

        这段代码中IOID在表格MFC_DATA中的Input和Output的数组长度

        | Input  | ARRAY[0..255] OF BOOL |
        | ------ | --------------------- |
        | Output | ARRAY[0..255] OF BOOL |

        我们需要定义相关的IOCmd和IOState，对于IOCmd可以去表格里搜索TP的所在位置，对于IOState可以去搜索TL的所在位置，例如

        | Tag_Name | Transaction_Name | Item_Name | Data_Type             |
        | -------- | ---------------- | --------- | --------------------- |
        | MFC_CMD  | MFC_CMD_Struct   | TP        | ARRAY[0..511] OF BOOL |

        | Tag_Name   | Event_Name              | Item_Name | Data_Type             |
        | ---------- | ----------------------- | --------- | --------------------- |
        | MFC_STATUS | MFC_STATUS_Struct_Block | TL        | ARRAY[0..511] OF BOOL |

        所以有了开始的代码，但是我们可以发现除了bool类型的IO，还有其他类型的例如float和int，可以通过如下命令来定义

        ```csharp
        iod.SetFloatIO(() => OrmonDataManager.MFC_PARA.MFC_PARA_Struct_Block.NormalPara_0);
        //iod.SetIntIO();
        ```

    5. 配置IO（一般情况，这个IO是要和电器沟通确定的）

        | 20  | ST1_WT吸真空1检 |
        | --- | --------------- |
        | 21  | ST1_WT破真空1检 |
        | 22  | ST1_WT吸真空2检 |
        | 23  | ST1_WT破真空2检 |

        | 20  | ST1_WT吸真空1 |
        | --- | ------------- |
        | 21  | ST1_WT破真空1 |
        | 22  | ST1_WT吸真空2 |
        | 23  | ST1_WT破真空2 |

        从表CMD_TPInfo和STATUS_TLInfo对照取出相应的输入输出的ID

        ```csharp
        var Whole = new IODefTree() { Name = "Whole" };
        Whole.AddBoolIO("ST1_WT吸真空1", 20, 20);
        Whole.AddBoolIO("ST1_WT破真空1", 21, 21);
        Whole.AddBoolIO("ST1_WT吸真空2", 22, 22);
        Whole.AddBoolIO("ST1_WT破真空2", 23, 23);
        iod.IOTrees.Add(Whole);
        ```

        这里的Whole标识一个分组，可能在特定情况有分组需求，这个也有树形的分组结构，如下可以通过AddChild方法添加子类数组。

        ```csharp
        var Whole = new IODefTree() { Name = "Whole" };
        Whole.AddBoolIO("打开水闸", 12, 12);
        Whole.AddBoolIO("关闭水闸", 13, 13);
        Whole.AddFloatIO("吸力", 19, 19);
        var innerTree1 = new IODefTree() { Name = "Inner1" };
        innerTree1.AddBoolIO("打开水闸", 14, 14);
        innerTree1.AddBoolIO("关闭水闸", 15, 15);
        Whole.AddChild(innerTree1);
        iod.IOTrees.Add(Whole);
        ```

    6. Alarm模块定义

        ```csharp
        AlarmDefination ad = new AlarmDefination()
        {
            AlarmIDStart = 0,
            AlarmIDEnd = 255,
            WarningIDStart = 0,
            WarningIDEnd = 255,
        };
        ad.SetAlarm(() => OrmonDataManager.MFC_DATA.MFC_DATA_Struct_Block.Alarm_0);
        ad.SetWarning(() => OrmonDataManager.MFC_DATA.MFC_DATA_Struct_Block.Warnning_0);
        ad.AddAlarm(0, 255, 0, 255);
        ad.AddWarning(0, 255, 0, 255);
        ```

        其中Alarm和Warning在DATA表格中

        | Tag_Name | Event_Name            | Item_Name | Data_Type             |
        | -------- | --------------------- | --------- | --------------------- |
        | MFC_DATA | MFC_DATA_Struct_Block | Alarm     | ARRAY[0..255] OF BOOL |
        |          |                       | Warnning  | ARRAY[0..255] OF BOOL |
        |          |                       | Input     | ARRAY[0..255] OF BOOL |
        |          |                       | Output    | ARRAY[0..255] OF BOOL |

        按照之前的声明，填写对应的结构即可，0-255是Alarm和Warnning的数组长度。

3. 运行程序，将`/debug/bin`中生成的plc_config.txt复制到输出目录下`Configuration/Card/Omron`中

### 2.4 配置轴PO

1. 安装MwFramework.Tools包，并将`/packages/MwFramework.Tools/tools`下的所有文件拷贝至输出目录
2. 在输出目录运行MwFramework.DeviceConfig.exe，选择AxisCardPO，在设备列表选择`添加`
	![](https://cdn.jsdelivr.net/gh/Ailurus-2233/PicGo-ImageRepo@main/work-Image/202308281100531.png.png)

    | 选项标签           | 释义     | 说明                               | 填写内容                              |
    | ------------------ | -------- | ---------------------------------- | ------------------------------------- |
    | AlarmOffset        | 警报偏移 |                                    | 0                                     |
    | AxisCardNum        | 轴卡号   | 填写定义的控制卡号，每个卡都不一样 | 0                                     |
    | AxisCardType       | 轴卡类型 | 类型                               | PLC                                   |
    | CategoryName       | 分类名称 | 显示的名称                         | card1                                 |
    | ConfigName         | 配置名称 | 不用写                             |                                       |
    | ConfigPath         | 配置路径 | 配置文件的路径，使用默认值即可     | AxisCardPO.xml                        |
    | ConfigType         | 配置类型 | 配置文件的类型，使用默认值即可     | MwFramework.Device.Drivers.AxisCardPO |
    | ConnectIp          | 链接的IP | 电器提供的ip地址                   | 192.168.250.1                         |
    | EnableLog          | 启用日志 | 是否启用日志                       | false                                 |
    | ID                 | ID       | 设备的唯一ID，使用默认生成的即可   |                                       |
    | IsUsed             | 是否使用 |                                    | false                                 |
    | ListAxisCardParaPO | 轴列表   | 点击...可以添加轴                  |                                       |
    | Password           | 密码     | 设备密码，没有可以不填             |                                       |
    | PortNo             | 端口号   | 电器提供，链接的端口号             | 0                                     |

    一般来说，需要注意的是CategoryName、AxisCardNum、以及ConnectIp和PortNo，CategoryName是用来标识这个轴卡的名称，是唯一标识，在程序通过检索名称来获取这个轴卡的具体实例；AxisCardNum是标识州的ID，也是唯一标识，用来标识轴与轴卡关系的；ConnectIp和PortNo一般来说可以不用填，但是需要注意部分特殊情况不填的话无法链接到硬件。

3. 选择ListAxisCardParaPo后面的`...`，在集合列表中选择`+`
    ![](https://cdn.jsdelivr.net/gh/Ailurus-2233/PicGo-ImageRepo@main/work-Image/202308281100532.png.png)

    | 选项标签     | 释义     | 说明                              | 填写内容                                  |
    | ------------ | -------- | --------------------------------- | ----------------------------------------- |
    | AlarmOffset  | 警报偏移 |                                   | 0                                         |
    | AxisCardld   | 控制卡ID | 用于表示从属关系时使用，可不填    | 0                                         |
    | AxisCardName | 轴卡名称 | 填写所属轴卡的CategoryName        | card1                                     |
    | AxisCardNum  | 轴卡编号 | 填写所属轴卡的AxisCardNum         | 0                                         |
    | AxisName     | 轴名称   | 参考电器提供的标签表MotionVelInfo | x1                                        |
    | AxisNum      | 轴号     | 参考电气提供的标签表MotionVelInfo | 0                                         |
    | CategoryName | 类型名称 | 显示的名称                        | x1                                        |
    | ConfigName   | 配置名称 | 不用写                            |                                           |
    | ConfigPath   | 配置路径 | 配置文件的路径，使用默认值即可    | AxisCardParaPO.xml                        |
    | ConfigType   | 配置类型 | 配置文件的类型，使用默认值即可    | MwFramework.Device.Drivers.AxisCardParaPO |
    | Direction    | 方向     | 轴的方向                          | X                                         |
    | EnableLog    | 启用日志 | 是否启用日志                      | false                                     |
    | ID           | ID       | 对于轴生成的唯一ID，使用默认      |                                           |
    | IsUsed       | 是否使用 | 是否使用该轴                      | false                                     |

    其中需要注意的是AxisCardName、AxisCardNum这要和轴卡的信息保持一致AxisName、AxisNum要与表格中的信息一一对应，

4. 选择确定→保存配置，即可将配置文件保存到输出文件的`Configuration/ModelMotion/AxisCardPO.xml`文件中

### 2.5 配置PLCPO

![](https://cdn.jsdelivr.net/gh/Ailurus-2233/PicGo-ImageRepo@main/work-Image/202308281100533.png.png)

IOType选择Omron，CategoryName设置为唯一值，是程序获取IO的唯一方式，选择保存配置，即可将配置文件保存到输出文件的`Configuration/ModelMotion/PlcIOsPO.xml`文件中


# 细节分析

## 1 OmronPLC的dll具体是起到什么作用的，为什么不同项目使用的dll都不一样

## 2 plc_config的作用是什么

## 3 plc_config配置的IO指的是什么