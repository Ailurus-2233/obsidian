# 任务目标

# 操作步骤

## 1.引用
Nuget：MaxwellFramework.AnimationManager.dll；

## 2.动画工具

在package下，找到AnimationTool.exe文件

![](https://cdn.jsdelivr.net/gh/Ailurus-2233/PicGo-ImageRepo@main/work-Image/202309071916996.png)


## 3.双击运行程序

![](https://cdn.jsdelivr.net/gh/Ailurus-2233/PicGo-ImageRepo@main/work-Image/202309071916762.png)


## 4.导入图片

右键->导入，选择图片
![](https://cdn.jsdelivr.net/gh/Ailurus-2233/PicGo-ImageRepo@main/work-Image/202309071916067.png)


## 5.调整窗体大小

缩放窗体尺寸保持与项目中的动画区域一致，否则会影响在项目中的布局

有2种导入图片方式
1. 一种是在窗体上导入图片，作为背景图存在
2. 一种是在背景图上插入，作为背景图的一种依存关系，拖动背景时通过带动上面插入的图片

## 6.调整图片

点击图片右键，可以对图片进行赋值，删除 排列顺序，在右侧轴属性内可以调整图片的高度，宽度，坐标，层号和缩放比例
![](https://cdn.jsdelivr.net/gh/Ailurus-2233/PicGo-ImageRepo@main/work-Image/202309071917772.png)

如果图片是需要动作的轴，需要设置轴名称
![](https://cdn.jsdelivr.net/gh/Ailurus-2233/PicGo-ImageRepo@main/work-Image/202309071917165.png)

## 7.轴动画
双击轴动画列表中的空白处，自动创建一个动画行信息，在下方输入动画属性，有动作名称，水平、垂直距离(像素尺寸)，移动时长，旋转角度，旋转时长，旋转中心（以图片的左上角为0,0点，右下角为1,1点；如以图片中心旋转的话设置为0.5,0.5），是否隐藏等动作,每个动作可以独立运行，也可以同时执行
![](https://cdn.jsdelivr.net/gh/Ailurus-2233/PicGo-ImageRepo@main/work-Image/202309071917300.png)


## 8.测试
动画效果可以通过轴动作列表内的启动按钮进行测试，同时可以在测试功能下，输入轴名称，动作名称和移动比例或旋转比例进行测试，
整个动画的执行使用绝对位置进行移动，执行整个动作完成比例为1，如果想回到原始位置则比例为0
![](https://cdn.jsdelivr.net/gh/Ailurus-2233/PicGo-ImageRepo@main/work-Image/202309071917651.png)

## 9.文件保存
动画功能设置好后，点击保存按钮，在工具目录下生成一个Animation文件夹，包含图片和存放的位置和动作信息
![](https://cdn.jsdelivr.net/gh/Ailurus-2233/PicGo-ImageRepo@main/work-Image/202309071918250.png)

## 10.加载动画

把Animation文件夹复制到项目的Bin目录下，在需要展示动画的页面中加载

```xml
<ContentControl Content="{Binding AnimationView}"/>
```

在ViewModel中定义动画对象

``` csharp
public AnimationContainer AnimationView { get; set; } = new AnimationContainer();
 
protected override void OnViewLoaded()
  {
     if (AnimationView.AnimationModelList.Count == 0)
    {
        // 动画加载
        AnimationView.Load();
            
        // 图片点击事件
        AnimationView.ImageClickEvent -= ShowPD;
        AnimationView.ImageClickEvent += ShowPD;
    }
  }
```

## 11.动画执行
定义DrivingModel 使用Action执行动作
``` csharp
DrivingModel drivingModel = new DrivingModel();
drivingModel.AxisName = "轴名称";
drivingModel.ActionName = "动作名称";
drivingModel.MoveScale = 0;
drivingModel.RotateScale = 0;
drivingModel.IsShowWL = false;
drivingModel.GlassID = string.Empty;
AnimationView.Action(drivingModel);
```

## 12.与轴进行关联动作
为了操作方便，可以预先定义好每个轴的动作模型
``` csharp
 //CO2移动
private DrivingModel _drivgModelCO2X1 = new DrivingModel() { AxisName = "Cut_CO2_1X", ActionName = "CO2_X1" };
private DrivingModel _drivgModelCO2X2 = new DrivingModel() { AxisName = "Cut_CO2_2X", ActionName = "CO2_X2" };
private DrivingModel _drivgModelCO2X3 = new DrivingModel() { AxisName = "Cut_CO2_3X", ActionName = "CO2_X3" };
private DrivingModel _drivgModelCO2X4 = new DrivingModel() { AxisName = "Cut_CO2_4X", ActionName = "CO2_X4" };

// CO2激光使能
private DrivingModel _drivgCO2X1Hide = new DrivingModel() { AxisName = "Cut_CO2_1X_Laser", ActionName = "V1" };
private DrivingModel _drivgCO2X1Show = new DrivingModel() { AxisName = "Cut_CO2_1X_Laser", ActionName = "V2" };

private DrivingModel _drivgCO2X2Hide = new DrivingModel() { AxisName = "Cut_CO2_2X_Laser", ActionName = "V1" };
private DrivingModel _drivgCO2X2Show = new DrivingModel() { AxisName = "Cut_CO2_2X_Laser", ActionName = "V2" };

private DrivingModel _drivgCO2X3Hide = new DrivingModel() { AxisName = "Cut_CO2_3X_Laser", ActionName = "V1" };
private DrivingModel _drivgCO2X3Show = new DrivingModel() { AxisName = "Cut_CO2_3X_Laser", ActionName = "V2" };

private DrivingModel _drivgCO2X4Hide = new DrivingModel() { AxisName = "Cut_CO2_4X_Laser", ActionName = "V1" };
private DrivingModel _drivgCO2X4Show = new DrivingModel() { AxisName = "Cut_CO2_4X_Laser", ActionName = "V2" };

// Load
private DrivingModel _drivgModelCutTF = new DrivingModel() { AxisName = "Cut_TF", ActionName = "S" };
private DrivingModel _drivgModelCutTFY = new DrivingModel() { AxisName = "Cut_TF_Y", ActionName = "CUT_TF_Y" };
private DrivingModel _drivgModelCutY = new DrivingModel() { AxisName = "Cut_Y", ActionName = "M1" };
private DrivingModel _drivgModelCutTH = new DrivingModel() { AxisName = "Cut_TH", ActionName = "TH1" };

// 可以定义一个检测最小差值的判断，防止微小变动就执行动画
/// <summary>
/// 检查当前轴移动位置与老的记录的动画位置之间的差值，用于判断是否可以移动
/// </summary>
/// <param name="actualPos">当前实际位置</param>
/// <param name="oldPos">老的记录的动画位置</param>
/// <returns>是否可以移动</returns>
private bool CheckAxisMoveOffset(double actualPos, double oldPos)
{
    const double MIN_OFFSET = 0.1;
    return Math.Abs(MathHelper.GetRound(actualPos) - MathHelper.GetRound(oldPos)) > MIN_OFFSET;
}
// 如果有多个连续动作时，需要把执行AnimationView.Action(drivingModel)的方法放到一个额Task里
Task.Run(() =>
    AnimationView.Action(drivingModel1);
    AnimationView.Action(drivingModel2);
});
```


# 细节分析