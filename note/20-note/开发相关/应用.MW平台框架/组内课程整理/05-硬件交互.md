# 任务目标

在全局硬件类配置获取对应的硬件，并学习使用接口方法来控制相应的硬件

# 操作步骤

## 1 报警机制

硬件注册报警

```csharp
foreach (var device in deviceList)
{
	device.DeviceAlarmStateChanged += DeviceOnDeviceAlarmStateChanged;
    //检查硬件，重新触发警报信息
    device.InitAlarm();
}
private void DeviceOnDeviceAlarmStateChanged(long alarmId, bool isSolved)
{
    IAlarmManager manager = IoC.Get<IAlarmManager>();
    if (!isSolved)
    {
        manager.HandleAlarmAsync(alarmId);
    }
    else
    {
        manager.HandleAlarmSolved(alarmId);
    }
}
```

## 2 Demo模式

### 2.1 全局Demo模式

编辑App.config文件的appSettings部分，声明Demo模式为true，这样所有的硬件实例都是最简单的实现对象，而且无需链接硬件。

```XML
<configuration>
  <!--...-->
  <appSettings>
    <!--...-->
    <add key="Demo" value="true" />
  </appSettings>
</configuration>
```


### 2.2 单个硬件Demo模式

在使用MwFramework.DeviceConfig.exe配置硬件时，可以在类型的地方选择DEMO，这样子这个单个硬件就可以加载Demo实例。

![](https://cdn.jsdelivr.net/gh/Ailurus-2233/PicGo-ImageRepo@main/work-Image/202308281100534.png.png.png)

## 3 IMwDevice Po

所谓的PO，也就是在MwFramework.DeviceConfig.exe这个工具中为每一个硬件配置的属性，框架通过解析配置生成的PO文件，将这些属性绑定到硬件的.PO属性中，例如

```C#
string s = card.Axises[0].PO.AxisCardName;
```

这样我们就可以取到在外部配置的硬件信息。

## 4 简单硬件接口

在编写程序时，往往需要和硬件的交互，这通常使用硬件实例中的方法成员来实现的，例如一个灯光设备，他需要的交互只是简单调整光的亮度以及打开关闭，这里框架提供这样的一个实例IMwLamp。

```csharp
// 获取硬件实例
IMwLamp lamp = deviceList.GetDevice<MwLight>("TestLamp");

// IMwLamp接口
public interface IMwLamp : IMwDevice
{
    LightPO PO { get; }
    uint ChannelNumber { get; }

    DriverLibResult GetIntensity(uint channel, ref int intensity); // 获取亮度
    DriverLibResult GetState(uint channel, ref bool onOff); // 获取状态
    DriverLibResult SetIntensity(uint channel, int value); // 设置亮度
    DriverLibResult SoftwareTrigger(uint channel, int time); // 触发器？
    DriverLibResult Turn(uint channel, bool onOff); // 开关
}
```

## 5 激光器接口

激光器是通过ILaser接口实例与软件进行交互的，其中包含了ILaserController，ILaserConfig，IMwDevice等其他接口，激光器的话由于厂商不会提供很通用的接口，而且不同厂商的接口往往差别很大，所以ILaser的接口设置会比较特殊。

```csharp
// 获取设备
ILaser laser = deviceList.GetDevice<ILaser>("");

// 设置属性
laser[(IntParamStr)"Power"].Param = 1;

// 等待属性设置完成
laser[(IntParamStr)"Power"].IsSetted().Wait();

// OR
if (laser[(IntParamStr)"Power"].IsSetted().Result)
{
    // 执行后续操作
}
```

这里通过索引器来获取属性和设置属性，这样设置并不知道是否设置完成，所以需要IsSetted方法来确认一下，这里有两种实现方式，都可以等待属性设置完成然后执行后去操作。

```csharp
// ILaserConfig
[DefaultMember("Item")]
[Obsolete]
public interface ILaserConfig : IEnumerable<BoxItem>, IEnumerable
{
    ILaserState<string> this[StringStateStr pName] { get; }
    ILaserState<double> this[FloatStateStr pName] { get; }
    ILaserState<int> this[IntStateStr pName] { get; }
    ILaserState<bool> this[BoolStateStr pName] { get; }
    ILaserParam<string> this[StringParamStr pName] { get; }
    ILaserEnumParam this[EnumParamStr pName] { get; }
    ILaserParam<double> this[FloatParamStr pName] { get; }
    ILaserParam<int> this[IntParamStr pName] { get; }
    ILaserParam<bool> this[BoolParamStr pName] { get; }
    ILaserState<Enum> this[EnumStateStr pName] { get; }

    ILaserState<double> Temperature { get; }
    ILaserParam<Enum> Gate { get; }
    ILaserParam<int> Frequence { get; }
    AbstractLaserPower Power { get; }
    ILaserParam<double> Current { get; }
    HashSet<string> StateNames { get; }
    HashSet<string> ParamNames { get; }
    ILaserParam<Enum> Mode { get; }

    ILaserParam GetParam(string name);
    ILaserState GetState(string name);
}
```

## 6 通用硬件接口

对于一些不好定义的接口的硬件设备时，可以使用IGeneralDevice接口来进行交互，它实现了IDeviceExtend和IDeviceParamExtend这两个接口，通过这两个接口中的方法来和硬件交互，而这个两个接口比较特殊，它通过一种字典的方式来获取硬件的属性

```csharp
// 获取硬件
IGeneralDevice generalDevice = deviceList.GetDevice<IGeneralDevice>("GeneralDevice");

// 获取属性
var value = ((IDeviceExtend)generalDevice)[(BoolStr)"BoolProp"].GetValue(); // TryGetValue(out bool);
var value = ((IDeviceParamExtend)generalDevice)[(BoolStr)"BoolProp"].Value;

// 设置属性
((IDeviceExtend)generalDevice)[(BoolStr)"BoolProp"].SetValue(true);
((IDeviceParamExtend)generalDevice)[(BoolStr)"BoolProp"].Value = true;
```

首先如果使用IGeneralDevice需要通过属性名称来获取相关属性，如上述代码，他从硬件中获取了一个Bool类型的属性，这个属性的名字为BoolProp，而对于IDeviceExtend和IDeviceParamExtend的区别就是前者通过方法来设置参数，而后者通过属性，方法的话可以设置超时和Token等来限制方法的执行，而后者则设置完属性后，并不关心后续的操作。从直观来看，似乎通过IDeviceExtend是比较优的选择，但是面对不同情况，两种方式都有使用场景。

```csharp
// IDeviceExtend
[DefaultMember("Item")]
public interface IDeviceExtend : IEnumerable<IBaseHandle>, IEnumerable
{
    IBaseHandle this[string name] { get; }
    IIntArrayDeviceHandle this[IntArrayStr name] { get; }
    IFloatArrayDeviceHandle this[FloatArrayStr name] { get; }
    IBoolArrayDeviceHandle this[BoolArrayStr name] { get; }
    IIntDeviceHandle this[IntStr name] { get; }
    IFloatDeviceHandle this[FloatStr name] { get; }
    IEnumDeviceHandle this[EnumStr name] { get; }
    ICommandDeviceHandle this[CommandStr name] { get; }
    IBoolDeviceHandle this[BoolStr name] { get; }
    IStringDeviceHandle this[StringStr name] { get; }

    bool ContainsKey(string name);
    bool ContainsKey(IntArrayStr name);
    bool ContainsKey(FloatArrayStr name);
    bool ContainsKey(BoolArrayStr name);
    bool ContainsKey(IntStr name);
    bool ContainsKey(FloatStr name);
    bool ContainsKey(EnumStr name);
    bool ContainsKey(CommandStr name);
    bool ContainsKey(StringStr name);
    bool ContainsKey(BoolStr name);
}

// IDeviceParamExtend
[DefaultMember("Item")]
public interface IDeviceParamExtend : IEnumerable<IBaseParam>, IEnumerable
{
    IBoolDeviceParam this[BoolStr name] { get; }
    ICommandDeviceParam this[CommandStr name] { get; }
    IEnumDeviceParam this[EnumStr name] { get; }
    IFloatDeviceParam this[FloatStr name] { get; }
    IIntDeviceParam this[IntStr name] { get; }
    IBoolArrayDeviceParam this[BoolArrayStr name] { get; }
    IFloatArrayDeviceParam this[FloatArrayStr name] { get; }
    IIntArrayDeviceParam this[IntArrayStr name] { get; }
    IStringDeviceParam this[StringStr name] { get; }
    IBaseParam this[string name] { get; }
}

```

## 7 轴接口

对于轴的操作就比较复杂了，它同样是需要使用一个名字为IAxis的接口，它实现了IAxisEvent、IAxisFunc、IAxisPosition这三个接口，其中IAxisFunc包含了关于轴运动的方法，

```csharp
IAxis axis = deviceList.GetDevice<IAxis>("Axis");
axis.Param.AbsPos = 1.0;
axis.AbsoluteMove();
axis.WaitPosition();
```

例如上述代码，轴的移动需要首先设定位置，然后使用AbsoluteMove，发出移动指令，但是这个是不会等待轴移动完成，所以需要调用WaitPosition来等待移动完成，后继续后面的指令。

```csharp
MotionErrorCode AbsoluteMove();
Task<MotionErrorCode> AbsoluteMoveAsync();
MotionErrorCode CancelWait();
MotionErrorCode GetSoftMel(ref double pos);
MotionErrorCode GetSoftPel(ref double pos);
MotionErrorCode Home();
MotionErrorCode IssueParam();
MotionErrorCode JogStart(Dir dir, bool state = true);
MotionErrorCode RelativeMove();
Task<MotionErrorCode> RelativeMoveAsync();
MotionErrorCode Reset();
MotionErrorCode Servo(bool servo);
MotionErrorCode SetSoftMel(double pos);
MotionErrorCode SetSoftPel(double pos);
MotionErrorCode StepNegative();
MotionErrorCode StepPositive();
MotionErrorCode StopMove();
bool WaitPosition(int timeout, CancellationToken token);
bool WaitPosition(int timeout = 10000000);
```

通过查看IAxisFunc接口，我们还发现了Sync方法，移动时同样可以是同Sync方法达到等待移动完成的目的。通过返回值可以是否移动完成等等。

## 8 相机接口

## 9 异步编程

值得注意的是，在于硬件交互的过程时，往往会存在发送完指令后不确定硬件是否接收到，或者就是一个异步的过程，目前最新版的平台已经考虑到这种情况，会设置一些Sync方法，Wait方法等等，来等待指令的执行，但是在过去的项目中，可能确少合适的异步机制，所以这里提供一些方法来供参考，在有异步需求的时候使用

```csharp
// 使用Task机制
IAxis axis1 = AxisList[0];
var tokenSoruce = new CancellationTokenSource();

axis1.Param.AbsPos = 1;
axis1.AbsoluteMove();

var t = Task.Factory.StartNew(() =>
{
    axis1.WaitPosition();
});
t.Wait(1000, tokenSoruce.Token);
axis1.CancelWait();
```

```csharp
using(tokenSoruce.Token.Register(() => axis1.CancelWait()))
{
    axis1.WaitPosition(1000);
}
```


# 细节分析

## 1 通过软件控制硬件可能会遇到那些问题，有什么处理办法

## 2 全局硬件类在设计上面会导致程序严重依赖IoC，有什么其他的程序设计思路降低模块对IoC的依赖