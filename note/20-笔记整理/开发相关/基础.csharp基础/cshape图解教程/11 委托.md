#csharp图解编程 #csharp学习 #学习笔记 

# 1 什么是委托

委托和类一样，是用户自定义类型。但类表示的是数据和方法的集合，而委托持有一个或多个方法，以及一系列预定义操作。

可以通过以下操作步骤来使用委托。
1. 声明一个委托类型。委托声明看上去和方法声明相似，只是没有实现块
2. 使用该委托类型声明一个委托变量
3. 创建委托类型的对象，把它赋值给委托变量。新的委托对象包括指向某个方法的引用，这个方法和第一步定义的签名和返回类型一致
4. 你可以选择为委托对象增加其他方法。这些方法必须与第一步中定义的委托类型有相同的签名和返回类型
5. 在代码中你可以像调用方法一样调用委托。在调用委托时，其包含的每个方法都会被执行


你可以把delegate看做一个包含有序方法列表的对象，这些方法的签名和返回类型相同。

1. 方法的列表称为调用列表
2. 委托保存的方法可以来自任何类或结构，只要它们在下面两点匹配
    1. 委托的返回类型
    2. 委托的签名（包括ref和out修饰符）
3. 调用列表中的方法可以是实例方法也可以是静态方法
4. 在调用委托时，会执行其调用列表中的所有方法

# 2 声明委托

```csharp
 关键字      委托类型名
   ↓            ↓
delegate void MyDel(int x);
          ↑           ↑
       返回类型       签名
```

委托类型声明看上去和方法的声明一样，但它不需要在类内部声明，因为它是类型声明

# 3 创建委托

1. 声明委托变量 
    MyDel delVar;
2. 创建对象可以使用new， 语法为new DelName(MethodName);
    delVar = new MyDel(mylnstObj.MyM1); // 实例方法
    delVar = new MyDel(SClass.OtherM2 ); // 静态方法
3. 除了为委托分配内存，创建委托对象还会把第一个方法放入委托的调用列表。

```csharp
MyDel delVar = mylnstObj.MyMl;
MyDel dVar = SClass.OtherM2;
```

由于委托是引用类型，我们可以通过给它赋值来改变包含在委托变量中的引用。旧的委托对象会被垃圾回收器回收。

# 4 组合委托
C#覆写了委托的运算符，可以通过+，+=，-=来组合委托
```csharp
MyDel delA = mylnstObj.MyMl;
MyDel delB = SClass.OtherM2；
MyDel delC = delA + delB; 

MyDel delVar = inst.MyMl; 
delVar += SCI.m3； 
delVar += X.Act;

delVar -= SCI.m3； 
```

对于`-=` 

1. 如果在调用列表中的方法有多个实例，-=运算符将从列表最后开始搜索，并且移除第一个与方法匹配的实例。
2. 试图删除委托中不存在的方法将无效
3. 试图调用空委托会抛出异常。可以通过将委托和null进行比较来判断委托的调用列表是否为空。如果调用列表为空，则委托是null。

# 5 委托调用
1. 可以通过两种方式调用委托。一种是像调用方法一样调用委托，另一种是使用委托的Invoke 方法。
2. 可以将参数放在调用的圆括号内。用于调用委托的参数作用于调 用列表中的每个方法。
3. 如果一个方法在调用列表中多次出现，则在调用委托时，每次在列表中遇到该方法时都会调用它。
4. 调用时委托不能为空（null）,否则将引发异常。可以使用if语句进行检查，也可以使用空条件运算符和Invoke方法。
5. 调用列表中最后一个方法返回的值就是委托调用返回的值。调用列表中所有其他方法的返回值都会被忽略。
6. 如果委托有引用参数，参数值会根据调用列表中的一个或多个方法的返回值而改变。

# 6 匿名委托
1. delegate类型关键字
2. 参数列表，如果语句块没有使用任何参数则可以省略
3. 语句块，它包含了匿名方法的代码。

```csharp
关键字     参数列表        语句块
  ↓           ↓             ↓
delegate(Parameters){ImplementationCode}
```

# 7 Lambda表达式

1. Lambda表达式参数列表中的参数必须在参数数量、类型和位置上与委托相匹配。
2. 表达式的参数列表中的参数不一定需要包含类型（隐式类型），除非委托有ref或out参数，此时必须注明类型（显式类型）。
3. 如果只有一个参数，并且是隐式类型的，则两端的圆括号可以省略，否则必须有括号。
4. 如果没有参数，必须使用一组空的圆括号。

```csharp
MyDel del=delegate(int x)    {return x+1;};//匿名方法
MyDel le1=        (int x) => {return x+1;};//Lambda表达式
MyDel le2=            (x) => {return x+1;};
MyDel le3=             x  => {return x+1;};
MyDel le4=             x  =>         x+1  ;
```