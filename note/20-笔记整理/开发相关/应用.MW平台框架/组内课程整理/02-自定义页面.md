# 任务目标

使用Layout.xml解析机制，从IoC中自动注入的自定义页面，并在程序中展示出来

# 操作步骤

## **IPage接口**

1. 主程序框架约定使用MVVM模式来构建页面，每个页面由一个`XXXView.xmal`文件和一个`XXXXViewModel.cs`文件组成。
2. 其中ViewMode文件中的ViewModel类需要继承IPage接口，并设置接口的Name属性为Layout文件里Target定义的某个名字，这样就可以把代码与程序页面绑定在一起。
3. 主程序框架约定，每个xxxxViewModel和它的View文件前面部分的名字是相同的，程序运行时，会自动找到ViewModel对应的View文件并把它显示到界面上。

### 1 创建XXXView.xaml和XXXViewModel.cs文件

其中对于XXXViewModel类需要实现接口IPage，且需要添加页面名称

```csharp
public class HomeViewModel : IPage
{
    public string Name { get; set; } = "PageName";
}
```

```XML
<UserControl x:Class="Demo.Home.View.HomeView"
             ...
             >
    <Grid>
        
    </Grid>
</UserControl>
```


### 2 在Layout.xml文件添加Target属性

```XML
<Page Name="页面名称" LangName="多语言名称" Target="PageName" />
```

同理，二级页面也是通过Target属性来绑定的页面

## IView接口

除了Page页面，我们可能还需要写一些其他组件，比如Footer，或者Page内部的某一部分。

可以通过在View'Model类型上面增加 [Inject(Key = "mykey")] 特性的方式将Key和这个类型关联起来。这里的Inject特性，是用来做IoC注册的（注：这里的IoC指的是主程序框架提供的IoC）。

### 1 创建XXXView.xaml和XXXViewModel.cs文件

其中对于XXXViewModel类需要实现接口IView接口，且需要Inject属性来绑定名称

```csharp
[Inject(Key="ControlName")]
public class XXXViewModel : IView
{

}
```

### 2 在Layout.xml文件添加Target属性

```XML
<Footer Target="ControlName" />
<!--OR-->
<Page Name="主页" LangName="Home" Target="Home" ControlBarTarget="ControlName"></Page>
```

## 执行结果

![](https://cdn.jsdelivr.net/gh/Ailurus-2233/PicGo-ImageRepo@main/work-Image/202309071702340.png)

![](https://cdn.jsdelivr.net/gh/Ailurus-2233/PicGo-ImageRepo@main/work-Image/202309071703592.png)

# 细节分析

## 1 为什么View.xaml能够和ViewModel.cs绑定到一起

## 2 框架在解析Layout.xml时具体执行了那些操作

## 3 除了使用Layout来自动注入自定义的控件，还有什么方法将自己写的控件放到一个页面上
