# 任务目标

使用参数机制和参数接口，设计实现一个自定义的参数，并在页面中展示对应的信息

# 操作步骤

## 1 创建一个参数类

- 增加类的特性 `[Export(typeof(IParameter))]`
- 继承参数基类ParameterBase
- 重写Copy方法，值得注意的是，这个Copy的方式意思是拷贝一个source到this实例，所以一般都是this.Prop = source.Prop，这样子

``` csharp
[Export(typeof(IParameter))]
public class TestParameter : ParameterBase
{

    public override void Copy(IParameter source)
    {
		base.Copy(source);
    }
}
```

值得注意的是
```csharp
public abstract class ParameterBase : IParameter
{
    public ParameterBase();

    [XmlIgnore]
    public virtual string FileName { get; }
    [XmlIgnore]
    public virtual string Dir { get; set; }
    [XmlIgnore]
    public UpdateCopy UpdateCopy { get; set; }

    public virtual void Copy(IParameter source);
    public void Read();
    public void Read(string path);
    public void Write();
    public void Write(string fileName);
}
```

这个参数类中，是定义了读和写的方法的，而且往往是需要手动的调用读写方法，这最主要的目的是为了保证参数的应用安全，需要手动的点击保存，这边是一个确认的过程

## 2 获取参数

通过IOC容器获取参数管理器IParameterManager实例转换微IParamList，调用GetParameter方法，指定参数的类型，注意每次调用GetParameter方法获取的参数是不同的副本（不同的实例）

```csharp
public interface IParameterManager
{
    bool Read(string fileName);
    bool Read();
    bool Write(string fileName);
    bool Write();
}
```

```csharp
public interface IParamList
{
    List<CutterParameter> Parameters { get; }
    Type[] ParamTypes { get; }
    List<IRecipeTabModel> RecipeParameters { get; }
    IRecipeService IMessage { get; set; }

    T GetParameter<T>() where T : IParameter;
    IRecipeTabModel GetRecipeOpenParameter<T>();
    T GetRecipeParameter<T>() where T : IRecipeParameter;
    List<T> ReadRecipe<T>(RecipeItem item) where T : IRecipeParameter;
    void Write(IRecipeParameter parameter);
}
```

```csharp
var ipm = IoC.Get<IParameterManager>();
var ipl = (IParamList)ipm;
var temp = ipl.GetParameter<TestParameter>();
```

一般是用过这种手段来获取具体一个参数的内容

## 3 参数同步

因为每一次获取参数时都是一个实例的拷贝，所以就会有参数同步的问题，为了提供参数保存数据同步机制，参数中Write方法发布CopyParameterWriteArgs事件，对应页面ViewModel实现`IHandle<CopyParameterWriteArgs>`，Handle方法注意对参数的类型进行判断

```csharp
public class TestParameterViewModel : IPage, IHandle<CopyParameterWriteArgs>
{
    public string Name { get; set; } = "TestParameter";

    private TestParameter tp;

    public TestParameterViewModel(IParameterManager parameterManager, IEventAggregator eventAggregator)
    {
        tp = (parameterManager as IParamList).GetParameter<TestParameter>();
        eventAggregator.Subscribe(this);
    }

    public void Handle(CopyParameterWriteArgs message)
    {
        if (message.Parameter != null && message.Parameter is TestParameter newPara)
        {
            tp = newPara;
        }
    }
}
```

这里使用了一个事件聚合器，会响应CopyParameterWriteArgs事件，但是任何一个配方都会Invoke这个事件，所以需要判断一下这个配方是否是目标配方，这样就可以完成配方同步

# 细节分析

## 1 使用参数的最主要目的是什么（使用环境）

## 2 事件聚合器的使用机制

## 3 IoC加载参数时做了哪些事情