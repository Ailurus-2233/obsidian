# 任务目标

学习使用配方机制以及相应的接口，实现一个配方页面

# 操作步骤

## 1 创建配方页面

### 1.1 创建RecipePageView.xaml

```XML
<UserControl x:Class="FrameworkDemo.Recipes.RecipesPageView"
             ...
             d:DesignHeight="450" d:DesignWidth="800">
    <Grid>
        <Grid>
            <ui:RecipeView DataContext="{Binding RecipeService}" />
        </Grid>
    </Grid>
</UserControl>
```


### 1.2 创建RecipePageViewModel.cs

```csharp
public class RecipePageViewModel : PropertyChangedBase, IPage, IRecipeComponent
{
    public string Name { get; set; } = "Recipe";

    private RecipeService recipeService;
    public RecipeService RecipeService
    {
        get => recipeService;
        set
        {
            recipeService = value;
            OnPropertyChanged(nameof(RecipeService));
        }
    }

    public RecipePageViewModel(IRecipeService recipeService)
    {
        RecipeService = (RecipeService)recipeService;
    }
}

```

IRecipeComponent 通过这个接口暴露出来当配方保存读取时的方法，可以通过修改这个方法来达到一些自定义的操作

### 1.3 引入MwFramework.ManagerService.dll

```Shell
MwFramework.ManagerService.dll
```


### 1.4 在Layout.xml添加页面绑定

```XML
<Page Name="配方" LangName="Recipe" Target="Recipe" />
```


### 1.5 启动程序选择配方页面可以看到

![image 5](https://cdn.jsdelivr.net/gh/Ailurus-2233/PicGo-ImageRepo@main/work-Image/202308281128331.png)

## 2 添加配方子页面

### 2.1 创建子页面需要的Parameter

```csharp
  public class TestRecipeParameter : IRecipeParameter
{
    public string TestParameter { get; set; } = "TestParameter";

    public IRecipeParameter Clone()
    {
        return (IRecipeParameter)MemberwiseClone();
    }
}
```


其中这个类需要实现`IRecipeParameter`接口，其中需要实现的方法时Clone，不过一般按照上面写的即可，然后既然是参数类，所以需要定义需要的参数，这里定义了一个TestParameter的string类型数据，简单代替需要读取的参数，如果这里是用到不能存储的对象，则需要使用`[XmlIgnore]`属性来标识。

### 2.2 创建子页面的xaml

```XML
<UserControl x:Class="Demo.Recipes.View.TestRecipeView"
             ...
             d:DataContext="{d:DesignInstance model:TestRecipeParameter}">
    <Grid>
        <TextBlock Text="{Binding TestParameter}"/>
    </Grid>
</UserControl>
```


其中数据上下文绑定到刚刚创建的Parameter类上，这里展示定义的`TestParameter`

### 2.3 创建子页面的ViewModel类

```csharp
public class TestRecipeViewModel : RecipeTabModelBase<TestRecipeParameter>
{
    public new string FileName => "TestRecipeParameter.xml";
}
```


这个ViewModel不需要去实现IPage接口，而是继承了`RecipeTabModelBase<>`这个泛型类，其中的泛型对应的第一步创建的Parameter类，我们可以显式的声明参数存放的文件名称，也可覆写生命周期中的各个函数来实现自定义过程，如`GetInstance()`，用来自定义获取实例时的操作，其他的可以去看源码。

### 2.4 修改RecipePageViewModel.cs

```csharp
public RecipePageViewModel(IRecipeService recipeService)
{
    var recipeItemViewModels = new ObservableCollection<RecipeItemViewModel>
    {
        new RecipeItemViewModel()
        {
            Header = "Test",
            TabModel = new TestRecipeViewModel()
        },
    };

    RecipeService = (RecipeService)recipeService;
    RecipeService.RecipeItemList = recipeItemViewModels;
    RecipeService.SelectedItem = RecipeService.RecipeItemList[0];
}
```


在构造函数声明一个子页面列表，其中包含每一个子页面对象`RecipeItemViewModel`,最后一句指令目的是设置默认页面为第1个子页面。

### 2.5 RecipePageView.xaml
```xml
<UserControl.Resources>
    <DataTemplate DataType="{x:Type viewmodel:TestRecipeViewModel}">
        <ContentControl mw:View.Model="{Binding}" />
    </DataTemplate>
</UserControl.Resources>
```

这里使用资源的方式，在这个页面创建了一个ViewModel，这样便可以通过框架中的机制来切换不同的子页面了

### 2.6 启动程序

![image 6](https://cdn.jsdelivr.net/gh/Ailurus-2233/PicGo-ImageRepo@main/work-Image/202308281128332.png)

可以看到配方的子页面已经加载进来了。

# 细节分析

