---
title: 巨量转移中路径生成的解决方案
category: 巨量转移
tags:
  - 项目整理
  - 巨量转移
date: 2023-10-16
---
# 1 工作问题说明

在巨量转移的过程中，有这样一个需求，上基板(doner)与下基板(beneficiary)的形状为矩形大小不一致，需要生成晶粒(grain)的对应关系来构成晶粒的转移路径，其中上下基板的对应关系会比较复杂，因为上基板的晶粒密度可能会大于下基板对应颜色的晶粒密度，所以这里有两种思路来解决这个问题：
1. 一个上基板可以通过位移的方式作用于下基板的不同区域
2. 一个上基板的作用于多个下基板的同一个区域。

已知条件：
1. 上下基板之间存在一个不为1的最大公约数$x$，振镜的工作范围$d$，与其的关系为$kd=x$，其中$k$为正整数，这样子振镜的工作范围刚好可以覆盖上下基板的全部范围。
2. 上基板的晶粒间隔$I_d$与下基板的晶粒间隔$I_b$存在关系 $I_b = kI_d$，其中$k$为正整数，这样只需要对齐一次，并且指定晶粒列表即可将当前振镜区域的下基板晶粒一一配对，同样只需要调整对位就可以将上基板剩余晶粒作用于另一个下基板。

如图
1. 基板分部情况

![上基板分部情况|300](https://cdn.jsdelivr.net/gh/Ailurus-2233/PicGo-ImageRepo@main/work-Image/202310111433597.png)

2. 下基板分部情况

![image.png|300](https://cdn.jsdelivr.net/gh/Ailurus-2233/PicGo-ImageRepo@main/work-Image/202310111435319.png)

# 2 问题解决方案

## 2.1 方案综述
整个过程包括三个部分：
1. 输入参数认证，需要对输入的晶粒间隔，上下基板的具体参数（如长度宽度等）进行检验，不符合规定的不进行后续步骤
2. 计算振镜范围、上基板、下基板三者的对应关系，主要是由于上下基板的宽高不一致，是一个多对多的数据关系
3. 构建上下基板每一个区域的对应关系，完成数据对应，并输出结果

## 2.2 输入

### 晶粒参数

``` java
Grain:
	double width // 晶粒宽度
	double height // 晶粒高度
```

> [!info] 注：
> 上下基板的晶粒宽度一致

### 通用基板参数

``` java
Wafer:
	int id                   // 基板id								 自动生成
	enmu shape               // 基板形状 Circle、Square				 手动输入
	enmu color               // 基板晶粒的颜色 Red、Green、Blue		 手动输入
	double width             // 基板宽度                             手动输入
	double height            // 基板宽度                             手动输入
	double radius            // 基板半径                             手动输入
	double interval_x        // 晶粒 x 方向间隔                      手动输入
	double interval_y        // 晶粒 y 方向间隔                      手动输入
	Point mark_1             // mark1 点位                           手动输入
	Point mark_2             // mark2 点位                           手动输入
	double offset_x          // 相较于 mark1 的偏移量                手动输入
	double offset_y          // 相较于 mark2 的偏移量                手动输入
	double count_x           // 当前上基板的晶粒数量X				 计算得到
	double count_y           // 当前上基板的晶粒数量Y                计算得到
	double real_width        // 基板只包含晶粒的范围宽度             计算得到
	double real_height       // 基板只包含晶粒的范围高度             计算得到
	List<Point> grains       // 晶粒点位列表                         计算得到
	List<TransArea> areas    // 根据振镜范围划分的列表               计算得到
```


### 上基板参数

``` java
Doner(Wafer)
```

> [!info] 注：
> 1. 输入的是三种颜色的上基板，其中 width、height、mark_1、mark_2、interval_x、interval_y、offset_x、offset_y 在目前需求中的三颜色基板参数是一致的。
> 2. count_x，count_y 是根据实际的数量计算得到的
> 3. real_width = count_x × interval_x
> 4. real_height = count_y × interval_x

### 下基板参数

``` java
Beneficiary(Wafer):
	double even_line_offset // 偶数行的偏移量            手动输入
```

> [!info] 注：
> 对应上基板同样有三种颜色的下基板，实际上这三种颜色是在同一个下基板上，但是为了方便转移路径的生成，设计成三个不同的对象

### 振镜参数

``` java
Laser:
	double width               // 振镜工作范围，正方形只记录宽度       手动输入
	int count_doner_x          // 在对应上基板可以转移的晶粒数量X	   计算得到
	int count_doner_y          // 在对应上基板可以转移的晶粒数量Y	   计算得到
	int count_beneficiary_x    // 在对应下基板可以转移的晶粒数量X	   计算得到
	int count_beneficiary_y    // 在对应下基板可以转移的晶粒数量Y	   计算得到
```

> [!info] 注：
> - count_doner_x = floor(width / doner.interval_x)
> - count_doner_y = floor(width / doner.interval_y)
> - count_beneficiary_x = floor(width / beneficiary.interval_x)
> - count_beneficiary_y = floor(width / beneficiary.interval_y)

## 2.3 输出

### 转移区域

``` java
TransArea:
	int id                 // 转移区域的ID
	List<point> grains     // 转移晶粒的点位
```

### 对应关系

``` java
TransData:
	int doner_id                 // 上基板ID
	int beneficiary_id           // 下基板ID
	int doner_area_id            // 上基板转移区域
	int beneficiary_area_id      // 下基板转移区域
	point doner_mark_point       // 上基板对位晶粒坐标
	point beneficiary_mark_point // 下基板对位晶粒坐标
```

> [!info] 注：
> 通过对应ID、区域ID和对位晶粒坐标构建一个转移区域关系列表，作为最终的输出

## 2.4 解决流程

> [!success] 参数要求
> 这里使用振镜范围作为一个转移区域，要求区域刚好能够均分上下基板，且要求上下基板能够对应，所以有以下关系：
> 1. 振镜与上下基板宽高关系，其中m和n是正整数
>
> ![image.png|500](https://cdn.jsdelivr.net/gh/Ailurus-2233/PicGo-ImageRepo@main/work-Image/202310171951394.png)
>
> 2. 上基板与下基板的宽高关系，其中n_x、m_x、n_y、m_y是正整数
>
> ![image.png|500](https://cdn.jsdelivr.net/gh/Ailurus-2233/PicGo-ImageRepo@main/work-Image/202310172000820.png)
>
> - 就是需要n个上基板和m个下基板，这种限制能够刚好整数配对

### 1 参数认证

#### 1.1 基板晶粒坐标生成

1. 根据输入参数确定基板边界

下面这个算法的输入是一个Wafer对象，Wafer就是带确定边界的基板

``` csharp
(double max_x, double max_y, double min_x, double min_y) GetGrainBorder(Wafer wafer) 
{
	// 计算获得一个准确点位
	Point point = (wafer.mark_1.X + wafer.offset_x, wafer.mark_1.Y + wafer.offset_y);
	
	double max_x = 0, max_y = 0, min_x = 0, min_y = 0;
	double horizon_border = wafer.shape == Circle ? wafer.radius : wafer.width / 2;
	double vertical_border = wafer.shape == Circle ? wafer.radius : wafer.height / 2;

	// 右边界
	max_x = point.X + wafer.interval_x * Math.Floor((horizon_border - point.X) / wafer.inteval_x

	// 左边界
    min_x = point.X - wafer.interval_x * Math.Floor((point.X + horizon_border) / wafer.inteval_x);

	// 上边界
	min_y = point.Y - wafer.interval_y * Math.Floor((point.Y + vertical_border) / wafer.inteval_x);

	// 下边界
	max_y = point.Y + wafer.interval_y * Math.Floor((vertical_border - point.Y) / wafer.inteval_x);  

	// 边界扩张，为了保证在存在偶数行偏移的情况下，不会出现边界的晶粒被去除的情况
	minX -= 5 * wafer.inteval_x;  
	minY -= 5 * wafer.inteval_y;  
	maxX += 5 * wafer.inteval_x;  
	maxY += 5 * wafer.inteval_y;

	return max_x, max_y, min_x, min_y;
}
```

2. 从左下到右上依次生成晶粒点位坐标

``` csharp
void CreateGrainPoint(Wafer wafer, double max_x, double max_y, double min_x, double min_y)
{
	// 准确点位
	Point point = (wafer.mark_1.X + wafer.offset_x, wafer.mark_1.Y + wafer.offset_y);
	
	// 偶数行偏移量
	var offset = wafer.type == Beneficiary ? wafer.even_line_offset : 0;

	// 新建列表对象
	wafer.grains = new List<Point>();

	// 从上到下，从左到右创建晶粒
	for (var y = minY; y <= maxY; y += grainIntervalY)
	{
	    var start = minX;
	    // 偶数行进行偏移
	    if (line++ % 2 == 0)
	    {
	        start += offset;
	    }
	    for (var x = start; x <= maxX; x += grainIntervalX)
	    {
	        var temp = new Point() { X = Math.Round(x, 8), Y = Math.Round(y, 8) };
	        wafer.grains.Add(temp);
	    }
	}

	// 检查 target 是否在晶粒集合中
	if (!wafer.grains.Contains(target))
	{
	    // 如果不在，则全部向右移动一个偏移量
	    for (var i = 0; i < wafer.grains.Count; i++)
	    {
	        wafer.grains[i] = new Point() { X = wafer.grains[i].X + offset, Y = wafer.grains[i].Y };
	    }
	}
}
```

3. 去除越出边界的晶粒点位

``` csharp
void DeleteOverBorder(Wafer wafer, Grain grain)
{
	double horizon_border = wafer.shape == Circle ? wafer.radius : wafer.width / 2;
	double vertical_border = wafer.shape == Circle ? wafer.radius : wafer.height / 2;

	// 去除超出边界的点
	if (wafer.shape == Circle)
	    wafer.grains.RemoveAll(w =>
	    {
	        var corners = new List<Point> {
	            new Point(w.X, w.Y),
	            new Point(w.X + grain.width, w.Y),
	            new Point(w.X, w.Y + grain.height),
	            new Point(w.X + grain.width, w.Y + grain.height)
	        };
	        foreach (var point in corners)
	        {
	            if (Math.Pow(point.X, 2) + Math.Pow(point.Y, 2) > Math.Pow(vertical_border, 2))
	            {
	                return true;
	            }
	        }
	        return false;
	    });
	else
	    RealGrainPointList.RemoveAll(w => (w.X <= -horizon_border) ||
	                                  (w.X + grian.width >= centerPointX + horizon_border) ||
	                                  (w.Y <= -vertical_border) ||
	                                  (w.Y + grain.height >= vertical_border));
}
```

#### 1.2 宽度关系转换为数量关系

在获得点位列表后，还需要进行一些操作，就算对象中那些计算获得的数据，来完善基板对象，以便于后续的操作，比如后续如果直接使用基板宽度可能会出现一些数量上的问题，所以这里采用的是将宽高转换为基板在横向和纵向数量，这样子就可以保证数量的准确性。

``` csharp
void CompleteWaferDate(Wafer wafer) 
{
	// 计算晶粒数量
	wafer.count_x = wafer.grains.GroupBy(p => p.Y).Select(s => s.Count()).Max();
	wafer.count_y = wafer.grains.GroupBy(p => p.X).Select(s => s.Count()).Max();

	// 计算基板只包含晶粒的范围
	wafer.real_width = wafer.count_x * wafer.interval_x;
	wafer.real_height = wafer.count_y * wafer.interval_y;
}
```

``` csharp
void CompleteLaserData(Wafer wafer, Laser laser)
{
	// 计算振镜可以转移的晶粒数量
	var interval_x = wafer.interval_x;
	var interval_y = wafer.interval_y;

	if (wafer.type == Beneficiary)
	{
		var temp = (int)Math.Ceiling(laser.width / interval_x);
		var temp = (int)Math.Ceiling(laser.width / interval_y);

		laser.count_beneficiary_x = laser.width % interval_x > grain.width ? temp + 1 : temp;
		laser.count_beneficiary_y = laser.width % interval_y > grain.height ? temp + 1 : temp;
	}
	else 
	{
		var temp = (int)Math.Ceiling(laser.width / interval_x);
		var temp = (int)Math.Ceiling(laser.width / interval_y);

		laser.count_doner_x = laser.width % interval_x > grain.width ? temp + 1 : temp;
		laser.count_doner_y = laser.width % interval_y > grain.height ? temp + 1 : temp;
	}
}
```

#### 1.3 下基板认证

对于下基板，原有的宽高和振镜工作范围的关系为

$$
\begin{aligned}
beneficiary.width &= m \times laser.width (m 是正整数) \\
beneficiary.height &= n \times laser.width (n 是正整数)
\end{aligned}
$$

这是长度数值之间的关系，在实际情况中根据长度分割下基板可能会导致部分晶粒处于分割线上，所以这里需要将长度转换为数量，这样子就可以保证晶粒的完整性

$$
\begin{aligned}
beneficiary.count_x &= m \times laser.count_beneficiary_x (m 是正整数) \\
beneficiary.count_y &= n \times laser.count_beneficiary_y (n 是正整数)
\end{aligned}
$$

但是理想情况下是刚好满足整数倍关系，但是一般情况下基板可能的最后一个分区会出现不满足整数倍的情况，这个在之后的转移流程中，认为是一个完整分区即可。所以这里的认证条件是

$$
\begin{aligned}
beneficiary.count_x &<= m \times laser.count_beneficiary_x \\
beneficiary.count_y &<= n \times laser.count_beneficiary_y \\
beneficiary.count_x &> (m-1) \times laser.count_beneficiary_x \\
beneficiary.count_y &> (n-1) \times laser.count_beneficiary_y \\
\end{aligned}
$$

但是实际代码中，$m$和$n$是通过下基板晶粒数量和振镜对应的数量相除后向上取整得到的，所以一定会满足这个条件，故而不需要进行认证，这里只是为了说明一下下基板和振镜的数量关系。

然而，这种策略是会产生一定的浪费，如果不能够满足整数倍关系，就会在上基板中存在一些剩余晶粒，并且这些晶粒也无法参与之后的转移作业，所以视情况对于浪费情况进行说明提醒。

> [!info] 注：
> 这里记录两个值 $m_b$，$n_b$，描述下基板和振镜工作范围的数量关系。

#### 1.4 上基板认证

**认证1：上下基板的间隔倍数需要为整数**
如果不为整数的话，每次只能转移一个晶粒，这样子会导致转移的效率非常低，所以这里需要进行认证，认证条件为
$$
\begin{aligned}
beneficiary.interval_x &= k_x \times doner.interval_x (k_x 是正整数) \\
beneficiary.interval_y &= k_y \times doner.interval_y (k_y 是正整数) \\
\end{aligned}
$$

**认证2：上基板与振镜关系**

对于上基板的认证这里有两种情况：

**上下基板大小不一致：** 即上下基板存在一定的倍率关系，这种情况需要多个上基板为下基板供料，那么在这种情况下，上基板的宽高和振镜工作范围的关系为$m_d$，$n_d$，但是计算方式有所不同。因为上基板是为了给下基板提供晶粒的，所以不允许出现晶粒数量不足的情况，所以这里的倍数关系是对应数量相除后向下取整得到的。

所以，上基板与振镜的关系为

$$
\begin{aligned}
doner.count_x &>= m \times laser.count_doner_x \\
doner.count_y &>= n \times laser.count_doner_y \\
doner.count_x &< (m+1) \times laser.count_doner_x \\
doner.count_y &< (n+1) \times laser.count_doner_y \\
\end{aligned}
$$


同样的由于是向下取整，所以一定会满足这个条件，所以不需要进行认证，这里只是为了说明一下上基板和振镜的数量关系。这种策略也会产生一定的浪费，即多余部分无法参与其他的转移作业，所以视情况对于浪费情况进行说明提醒。

**上下基板大小一致：** 这种情况一个上基板可以为一个下基板完整供料，那么在这种情况，同样可以允许上基板的最后一行的区域或最后一列的区域不用是完整的范围。但是这里得要求上基板和下基板的数量关系，需要上基板能够为多个下基板供料，即具体的对应关系为

$$
\begin{aligned}
doner.count_x &>= k_x \times beneficiary.count_x \\
doner.count_y &>= k_y \times beneficiary.count_y
\end{aligned}
$$

如果不满足则需要终止程序继续执行。

#### 1.5 考虑到奇偶行的情况

对于下基板晶粒的分布可能存在奇偶行不同的情况，也就是之前图中所绘制的情况，这里在程序将奇偶行分成两个不同的下基板来构成，奇数行与偶数行的晶粒点位分别构成一个新的Beneficiary对象，并将其中的interval_y变为原来的两倍。


### 2 参数对应关系计算

#### 2.1 振镜对于下基板

#### 2.2 振镜对于上基板

#### 2.3 上基板对于下基板

#### 2.4 考虑奇偶行不同的情况

### 3 构建区域的对应关系列表

#### 3.1 划分上下基板区域

#### 3.2 配对生成对应关系

#### 3.3 输出结果

## 检验测试

### 测试数据

### 测试结果


# 其他杂项整理
