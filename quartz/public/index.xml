<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
    <channel>
      <title>小熊の杂货铺~</title>
      <link>https://blog.ailurus2233.site</link>
      <description>Last 10 notes on 小熊の杂货铺~</description>
      <generator>Quartz -- quartz.jzhao.xyz</generator>
      <item>
    <title>docker部署piclist server</title>
    <link>https://blog.ailurus2233.site/02-%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/docker/%E4%BD%BF%E7%94%A8docker%E9%83%A8%E7%BD%B2piclist-server</link>
    <guid>https://blog.ailurus2233.site/02-%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/docker/%E4%BD%BF%E7%94%A8docker%E9%83%A8%E7%BD%B2piclist-server</guid>
    <description>新建 node 容器 § 编辑文件 docker-compose.yml § services: caddy: image: node:16.20.1 container_name: piclist restart: always networks: caddy: stdin_open: true tty: true networks: caddy: external: true 启动 node 容器 § docker compose up -d 安装PicList § 进入 node 容器 § docker exec -it piclist bash 修改国内安装源 § npm config set sharp_binary_host &quot;https://npm.</description>
    <pubDate>Thu, 30 Nov 2023 02:42:54 GMT</pubDate>
  </item><item>
    <title>安装docker</title>
    <link>https://blog.ailurus2233.site/02-%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/docker/%E5%AE%89%E8%A3%85docker</link>
    <guid>https://blog.ailurus2233.site/02-%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/docker/%E5%AE%89%E8%A3%85docker</guid>
    <description>Arch § 安装docker sudo pacman -S docker 启动docker sudo systemctl start docker.service 开机自动启动 sudo systemctl enable docker.service 将用户添加到docker组 sudo gpasswd -a $USER docker 修改镜像位置 /etc/docker/daemon.</description>
    <pubDate>Thu, 30 Nov 2023 02:42:54 GMT</pubDate>
  </item><item>
    <title>docker常用容器安装指令</title>
    <link>https://blog.ailurus2233.site/02-%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/docker/docker%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8%E5%AE%89%E8%A3%85%E6%8C%87%E4%BB%A4</link>
    <guid>https://blog.ailurus2233.site/02-%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/docker/docker%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8%E5%AE%89%E8%A3%85%E6%8C%87%E4%BB%A4</guid>
    <description>gitea § mkdir -p ~/docker/gitea version: &quot;3&quot; networks: gitea: external: false services: server: image: gitea/gitea:1.20.5 container_name: gitea environment: - USER_UID=1000 - USER_GID=1000 restart: always networks: - gitea volumes: - ~/docker/gitea:/data - /etc/timezone:/etc/timezone:ro - /etc/localtime:/etc/localtime:ro ports: - &quot;3000:3000&quot; - &quot;22:22&quot; docker-compose up -d nginx § mkdir -p ~/docker/nginx/conf mkdir -p ~/docker/nginx/conf.</description>
    <pubDate>Thu, 30 Nov 2023 02:42:54 GMT</pubDate>
  </item><item>
    <title>高并发场景下，怎么保证数据的一致性的</title>
    <link>https://blog.ailurus2233.site/02-%E7%AC%94%E8%AE%B0/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF%E4%B8%8B%EF%BC%8C%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84</link>
    <guid>https://blog.ailurus2233.site/02-%E7%AC%94%E8%AE%B0/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF%E4%B8%8B%EF%BC%8C%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84</guid>
    <description>简述 § 高并发的场景下，往往需要缓存数据库+实际数据库来减轻数据库的检索压力，加快查询效率。然而一份数据存储在两个地方，更新数据的时候，往往会出现数据不一致的情况，比如实际数据库更新了数据，但是缓存数据库没有更新等等，所以这时候设计逻辑就需要考虑到数据库更新时的流程。 整理一下，可以描述为 一致性就是数据保持一致，在分布式系统中，可以理解为多个节点中数据的值是一致的。 强一致性：这种一致性级别是最符合用户直觉的，它要求系统写入什么，读出来的也会是什么，用户体验好，但实现起来往往对系统的性能影响大 弱一致性：这种一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的值，也不承诺多久之后数据能够达到一致，但会尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态 最终一致性：最终一致性是弱一致性的一个特例，系统会保证在一定时间内，能够达到一个数据一致的状态。这里之所以将最终一致性单独提出来，是因为它是弱一致性中非常推崇的一种一致性模型，也是业界在大型分布式系统的数据一致性上比较推崇的模型 保证数据一致性，一般有这4种方法： 先更新缓存，再更新数据库。 先更新数据库，再更新缓存。 先删除缓存，再更新数据库。 先更新数据库，再删除缓存。 一般情况分析 § 1 先更新缓存，再更新数据库： § 如果同时来了两个并发写请求，执行过程是这样的： 写请求1更新缓存，设置值为1 写请求2更新缓存，设置值为2 写请求2更新数据库，设置值为2 写请求1更新数据库，设置值为1 执行结果就是，缓存里值被设置2，数据库里的值被设置成1，导致数据不一致，此方案不可行。 2 先更新数据库，再更新缓存 § 如果同时来了两个并发写请求，执行过程是这样的： 写请求1更新数据库，设置值为1 写请求2更新数据库，设置值为2 写请求2更新缓存，设置值为2 写请求1更新缓存，设置值为1 执行结果就是，数据库里值被设置2，缓存里的值被设置成1，导致数据不一致，此方案不可行。 3 先删除缓存，再更新数据库 § 如果同时来了两个并发读写请求，执行过程是这样的： 写请求删除了缓存 读请求查询缓存没数据，然后查询数据库，再把数据写到缓存中 写请求更新数据库 执行结果是，缓存中是旧数据，而数据库里是新数据，导致数据不一致，此方案不可行。 4 先更新数据库，再删除缓存 § 这种方案，在并发写的时候，不会出问题。因为都是先更新数据库再删除缓存，不会出现不一致的情况。 但是在并发读写的时候，还是有可能出现数据不一致。 读请求查询缓存没数据，然后查询数据库 写请求更新数据库，删除缓存 读请求回写缓存 执行结果是，缓存中是旧数据，而数据库里是新数据，导致数据不一致。但其实这种情况出现的概率很低，写缓存比写数据库快出几个量级，读写缓存都是内存操作，速度非常快。遇到了这种极端场景，我们也需要做一下兜底方案，缓存都要设置过期时间。这种方案属于数据的弱一致性和最终一致性，而不是强一致性。.</description>
    <pubDate>Wed, 29 Nov 2023 00:00:00 GMT</pubDate>
  </item><item>
    <title>测试理论基础</title>
    <link>https://blog.ailurus2233.site/02-%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80</link>
    <guid>https://blog.ailurus2233.site/02-%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80</guid>
    <description>1 什么是软件测试 § 用来促进鉴定软 件的正确性、完整性、安全性和质量的过程； 是一种实际输出与预期输出间的审核或者比较过程； 使用人工和自动手段来运行或测试某个系统的过程，其目的在于检验它是否满足规定的需求或是弄清预期结果与实际结果之间的差别； 2 软件测试的分类 § 按开发阶段来分：单元测试、集成测试、系统测试、验收测试。 按测试的实施单位来分：开发方测试、用户测试、第三方测试。 按测试技术来分：白盒测试、黑盒测试、灰盒测试。 3 软件测试的常用种类 § 黑盒测试： 把测试对象看做一个黑盒子，测试人员完全不考虑程序内部的逻辑结构和内部特性，只依据程序的需求规格说明书，检查程序的功能是否符合它的功能说明。因此黑盒测试又叫功能测试或数据驱动测试。 黑盒测试方法包括：等价类划分、边界值分析、因果图分析、错误推测法、功能图分析等。 白盒测试： 是对软件的过程性细节做细致的检查。是把测试对象看做一个打开的盒子，它允许测试人员利用程序内部的逻辑结构及有关信息，设计或选择测试用例，对程序所有逻辑路径进行测试。通过在不同点检查程序状态，确定实际状态是否与预期的状态一致。因此白盒测试又称为结构测试或逻辑驱动测试。 白盒测试方法包括：语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、条件组合覆盖、路径覆盖等。 单元测试： 是对软件中的基本组成单位进行的测试，如一个模块、一个过程等等。它是软件动态测试的最基本的部分，也是最重要的部分之一，其目的是检验软件基本组成单位的正确性。一个软件单元的正确性是相对于该单元的规约(详细设计)而言的。因此，单元测试以被测试单位的规约为基准。 单元测试方法包括：控制流测试、数据流测试、排错测试、分域测试等。 集成测试： 是在软件系统集成过程中所进行的测试，其主要目的是检查软件单位之间的接口是否正确。它根据集成测试计划，一边将模块或其他软件单位组合成越来越大的系统，一边运行该系统，以分析所组成的系统是否正确，各组成部分是否合拍。集成测试的策略主要有自顶向下和自底向上两种。 系统测试： 是对已经集成好的软件系统进行彻底的测试，以验证软件系统的正确性和性能等满足其规约所指定的要求，检查软件的行为和输出是否正确并非一项简单的任务，它被称为测试的“先知者问题”。因此，系统测试应该按照测试计划进行，其输入、输出和其他动态运行行为应该与软件规约进行对比。 软件系统测试方法很多，主要有功能测试、性能测试、随机测试等。 验收测试： 由客户或最终用户执行，旨在向软件的购买者展示该软件系统满足其用户的需求。它的测试数据通常是系统测试的测试数据的子集。所不同的是，验收测试常常有软件系统的购买者代表在现场，甚至是在软件安装使用的现场。这是软件在投入使用之前的最后测试。 功能测试： 对产品的各功能进行验证，根据功能测试用例，逐项测试，检查产品是否达到用户要求的功能。 性能测试： 是通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。负载测试和压力测试都属于性能测试，两者可以结合进行。通过负载测试，确定在各种工作负载下系统的性能，目标是测试当负载逐渐增加时，系统各项性能指标的变化情况。压力测试是通过确定一个系统的瓶颈或者不能接收的性能点，来获得系统能提供的最大服务级别的测试。 负载测试： 数据在超负荷环境下运行，测试软件系统是否能够承担。这种超负荷主要指多并发用户。通常需要人为生成大数据量，并利用工具模拟频繁并发访问，主要考察诸如响应时间、交易容量、资源使用率等指标。 压力测试： 指系统不断施加越来越大的负载（并发，循环操作，多用户，网络流量）的测试。通过确定一个系统的瓶颈或者不能接收的性能点，来确定系统能提供的最大服务级别的测试。 恢复测试： 恢复测试主要检查系统的容错能力。当系统出错时，能否在指定时间间隔内修正错误并重新启动系统。恢复测试首先要采用各种办法强迫系统失败，然后验证系统是否能尽快恢复。如果系统恢复是自动的（即恢复由系统自身完成），则应该检验以下内容：重新初始化、检验点设置机构、数据恢复以及重新启动是否正确。 可用性测试： 可用性测试是面向用户的系统测试。让一群有代表性的用户尝试对产品进行典型操作，同时观察员和开发人员在一旁观察，聆听，做记录。 兼容性测试： 测试软件在一个特定的硬件、软件、操作系统、网络等环境下系统能否正常运行。检验被测软件对其他应用软件或者其他系统的兼容性。 安全性测试： 安全测试检测系统对非法入侵的防范能力。例如，应用程序级别的安全性测试，数据库安全性测试，系统级别的安全性测试等等。 冒烟测试： 可以根据其名称理解为该种测试耗时短；其实是对软件基本的功能进行测试，测试的对象是每一个新编译的需要正式测试的软件版本，目的是确认软件基本的功能正常，保证软件系统能跑得起来，可以进行后续的正式测试工作。 回归测试： 是指修改了旧代码后，重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误，回归测试的困难在于不好确定哪些内容应当被重新测试。 随机测试： 主要是根据测试者的经验对软件进行功能和性能抽查。它是根据测试说明书执行样例测试的重要补充手段，是保证测试覆盖完整性的有效方式和过程。 动态测试： 是指通过运行被测程序，检查运行结果与预期结果的差异，并分析运行效率和健壮性等性能，这种方法由三部分组成：构造测试实例、执行程序、分析程序的输出结果。所谓软件的动态测试，就是通过运行软件来检验软件的动态行为和运行结果的正确性。目前，动态测试也是公司的测试工作的主要方式。 静态测试： 是指不运行被测程序本身，仅通过分析或检查源程序的语法、结构、过程、接口等来检查程序的正确性。对需求规格说明书、软件设计说明书、源程序做结构分析、流程图分析、符号执行来找错。静态方法通过程序静态特性的分析，找出欠缺和可疑之处，例如不匹配的参数、不适当的循环嵌套和分支嵌套、不允许的递归、未使用过的变量、空指针的引用和可疑的计算等。静态测试结果可用于进一步的查错，并为测试用例选取提供指导。 UI测试： 指测试用户界面的风格是否满足客户要求，文字是否正确，页面美工是否好看，文字，图片组合是否完美，背景是否美观，操作是否友好等；用户界面(UI)测试用于核实用户与软件之间的交互。UI测试的目标是确保用户界面会通过测试对象的功能来为用户提供相应的访问或浏览功能。另外，UI测试还可确保UI中的对象按照预期的方式运行，并符合公司或行业的标准。包括用户友好性，人性化，易操作性测试。UI测试比较主观，与测试人员的喜好有关。 自动化测试： 利用软件测试工具自动实现全部或部分测试，它是软件测试的一个重要组成部分，能完成许多手工测试无法实现或难以实现的测试；正确、合理的实施自动测试，能够快速、全面的对软件进行测试，从而提高软件质量，节省经费，缩短软件发布周期。.</description>
    <pubDate>Wed, 29 Nov 2023 00:00:00 GMT</pubDate>
  </item><item>
    <title>测试用例八大设计方法</title>
    <link>https://blog.ailurus2233.site/02-%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E5%85%AB%E5%A4%A7%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95</link>
    <guid>https://blog.ailurus2233.site/02-%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E5%85%AB%E5%A4%A7%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95</guid>
    <description>测试方法分类： § 黑盒测试 ：等价类划分 边界值分析 因果图分析 错误测试 白盒测试：语句覆盖 判定覆盖 条件覆盖 判定/条件覆盖 多重条件覆盖 黑盒测试 § 等价类划分方法 § 等价类划分：指某个输入域的子集合。在该子集合中，各个输入数据对于揭露程序中的错误都是等效的，并合理地假定；测试某等价类的代表值就等于对这一类其它值的测试。因此，可以把全部输入数据合理划分为若干等价类，在每一个等价类中取一个数据作为测试的输入条件，就可以用少量代表性的测试数据，取得较好的测试结果。 等价类划分可有两种不同的情况：有效等价类和无效等价类。 边界值分析方法 § 边界值：是对等价类划分方法的补充，测试工作经验告诉我,大量的错误是发生在输入或输出范围的边界上，而不是发生在输入输出范围的内部。因此针对各种边界情况设计测试用例，可以查出更多的错误。使用边界值分析方法设计测试用例，首先应确定边界情况。通常输入和输出等价类的边界，就是应着重测试的边界情况。应当选取正好等于，刚刚大于或刚刚小于边界的值作为测试数据，而不是选取等价类中的典型值或任意值作为测试数据。 错误推测方法 § 错误推测：基于经验和直觉推测程序中所有可能存在的各种错误，从而有针对性的设计测试用例的方法。 错误推测方法的基本思想：列举出程序中所有可能有的错误和容易发生错误的特殊情况，根据他们选择测试用例。例如：在单元测试时曾列出的许多在模块中常见的错误。以前产品测试中曾经发现的错误等，这些就是经验的总结。还有，输入数据和输出数据为0的情况。输入表格为空格或输入表格只有一行。这些都是容易发生错误的情况。可选择这些情况下的例子作为测试用例。 因果图方法 § 前面介绍的等价类划分方法和边界值分析方法，都是着重考虑输入条件,但未考虑输入条件之间的联系，相互组合等。考虑输入条件之间的相互组合，可能会产生一些新的情况。但要检查输入条件的组合不是一件容易的事情,即使把所有输入条件划分成等价类，他们之间的组合情况也相当多。因此必须考虑采用一种适合于描述对于多种条件的组合，相应产生多个动作的形式来考虑设计测试用例。这就需要利用因果图（逻辑模型）。因果图方法最终生成的就是判定表。它适合于检查程序输入条件的各种组合情况。 白盒测试 § 判定表驱动分析方法 § 判定表：是分析和表达多逻辑条件下执行不同操作的情况的工具。 正交表设计分析方法 § 有时候，可能因为大量的参数的组合而引起测试用例数量上的激增，同时，这些测试用例并没有明显的优先级上的差距，而测试人员又无法完成这么多数量的测试，就可以通过正交表来进行缩减一些用例，从而达到尽量少的用例覆盖尽量大的范围的可能性。 功能图分析方法 § 功能图：由状态迁移图和布尔函数组成，状态迁移图用状态和迁移来描述。一个状态指出数据输入的位置（或时间），而迁移则指明状态的改变。同时要依靠判定表或因果图表示的逻辑功能。 场景模拟分析方法 § 指根据用户场景来模拟用户的操作步骤,这个比较类似因果图,但是可能执行的深度和可行性更好。.</description>
    <pubDate>Wed, 29 Nov 2023 00:00:00 GMT</pubDate>
  </item><item>
    <title>软件开发模型</title>
    <link>https://blog.ailurus2233.site/02-%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B</link>
    <guid>https://blog.ailurus2233.site/02-%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B</guid>
    <description>瀑布模型 § 开发流程 § 计划时期：问题定义，可行性分析 开发时期：需求分析，软件设计，编码，测试 运行时期：维护 主要特征 § 特点： 1.里程碑或基线驱动。2.过程逆转性很差或者说不可逆转。逆转可能会延误工期，增加成本，造成损失 优点： 1.开发阶段清晰，便于评审、审计、跟踪、管理和控制。 缺点： 1.</description>
    <pubDate>Wed, 29 Nov 2023 00:00:00 GMT</pubDate>
  </item><item>
    <title>软件测试的基本流程</title>
    <link>https://blog.ailurus2233.site/02-%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B</link>
    <guid>https://blog.ailurus2233.site/02-%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B</guid>
    <description>基本流程 § 测试需求分析阶段：阅读需求，理解需求，主要就是对业务的学习，分析需求点，参与需求评审会议 制定测试计划阶段：主要任务就是编写测试计划，参考软件需求规格说明书，项目总体计划，内容包括测试范围（来自需求文档），进度安排，人力物力的分配，整体测试策略的制定。风险评估与规避措施有一个制定。 测试设计阶段：主要是编写测试用例，会参考需求文档（原型图），概要设计，详细设计等文档，用例编写完成之后会进行评审。 测试执行阶段：搭建环境，执行冒烟测试（预测试）-然后进入正式测试，bug管理直到测试结束 测试评估阶段：出测试报告，确认是否可以上线 软件生命周期 § 是指从软件的产生直到报废的整个周期，包括可行性分析与项目计划，需求分析，概要设计和详细设计，编码，调试，维护七个阶段。 软件测试生命周期 § 是指从测试项目计划建立到BUG提交的整个测试过程，包括软件项目测试计划，测试需求分析，测试用例设计，测试用例执行，BUG提交五个阶段。也可以是（测试计划 → 测试设计 → 测试开发 → 测试执行 → 测试评估）。软件测试生命周期并行与软件生命周期，存在于软件生命周期的各个阶段。.</description>
    <pubDate>Wed, 29 Nov 2023 00:00:00 GMT</pubDate>
  </item><item>
    <title>分类说明</title>
    <link>https://blog.ailurus2233.site/00-%E5%85%B3%E4%BA%8E/%E5%88%86%E7%B1%BB%E8%AF%B4%E6%98%8E</link>
    <guid>https://blog.ailurus2233.site/00-%E5%85%B3%E4%BA%8E/%E5%88%86%E7%B1%BB%E8%AF%B4%E6%98%8E</guid>
    <description>这个模块是对博主本人一个说明，许多关于我的信息可以在这里找到，比如联系方式、当前的工作、近期的状态、工作情况、最近在忙的一些事情等等。 以下是这一模块的目录 00-关于我 01-教育经历 02-工作经历 03-资质证书 04-获奖经历 05-个人成果 .</description>
    <pubDate>Wed, 15 Nov 2023 16:00:00 GMT</pubDate>
  </item><item>
    <title>关于我</title>
    <link>https://blog.ailurus2233.site/00-%E5%85%B3%E4%BA%8E/%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/00-%E5%85%B3%E4%BA%8E%E6%88%91</link>
    <guid>https://blog.ailurus2233.site/00-%E5%85%B3%E4%BA%8E/%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/00-%E5%85%B3%E4%BA%8E%E6%88%91</guid>
    <description>基本信息 § 姓名：****** （不可说~，一般还是叫我Ailurus，可以读艾露露~） 性别：男 年龄：26 联系方式： Github: Ailurus-2233 (Aillurus2233) (github.com) E-mail: Ailurus2233@outlook.com WeChat: Zyu_Work 个人性格 § 个人性格真的很难总结的很恰当，就随便写写，希望以下的话能让你对我有个初步的认识。 爱好的话，还是喜欢玩游戏，最想的生活就是，一天工作结束后可以在电脑前玩自己想玩的游戏（我是原X），除此之外的话，比较喜欢看一些纪录片、动漫之类的视频；喜欢唱歌，但是工作之后就没再去过KTV（工作太忙了，可恶啊！！！） 在工作学习上的话，个人觉得自己还是一个认真负责的人，喜欢去钻研一些新的技术（俗称瞎折腾），当然在工作任务上面更喜欢有明确目标的去完成，那些开放型的任务对我来说有点点难搞，（也不知道做到什么程度合适，就是总感觉做的不太够，然后逼得自己去卷） 个人生活中的话，emmmm，社恐，hin社恐，就是一个内向的程序员，但是可能在网上就体现的不是很明显，但不是键盘侠，不喜欢随意的去责难一些人或者事，网上和生活中都一样。.</description>
    <pubDate>Wed, 15 Nov 2023 16:00:00 GMT</pubDate>
  </item>
    </channel>
  </rss>